"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionLocalStorage = void 0;
const viem_1 = require("viem");
const aa_core_1 = require("@alchemy/aa-core");
const chains_1 = require("viem/chains");
const accounts_1 = require("viem/accounts");
class SessionLocalStorage {
    constructor(smartAccountAddress) {
        Object.defineProperty(this, "smartAccountAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.smartAccountAddress = smartAccountAddress.toLowerCase();
    }
    validateSearchParam(param) {
        if (param.sessionID) {
            return;
        }
        else if (!param.sessionID && param.sessionPublicKey && param.sessionValidationModule) {
            return;
        }
        else {
            throw new Error("Either pass sessionId or a combination of sessionPublicKey and sessionValidationModule address.");
        }
    }
    getSessionStore() {
        const data = localStorage.getItem(this.getStorageKey("sessions"));
        return data ? JSON.parse(data) : { merkleRoot: "", leafNodes: [] };
    }
    getSignerStore() {
        const data = localStorage.getItem(this.getStorageKey("signers"));
        return data ? JSON.parse(data) : {};
    }
    getStorageKey(type) {
        return `${this.smartAccountAddress}_${type}`;
    }
    toLowercaseAddress(address) {
        return address.toLowerCase();
    }
    async addSessionData(leaf) {
        const data = this.getSessionStore();
        leaf.sessionValidationModule = this.toLowercaseAddress(leaf.sessionValidationModule);
        leaf.sessionPublicKey = this.toLowercaseAddress(leaf.sessionPublicKey);
        data.leafNodes.push(leaf);
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async getSessionData(param) {
        this.validateSearchParam(param);
        const sessions = this.getSessionStore().leafNodes;
        const session = sessions.find((s) => {
            if (param.sessionID) {
                return s.sessionID === param.sessionID && (!param.status || s.status === param.status);
            }
            else if (param.sessionPublicKey && param.sessionValidationModule) {
                return (s.sessionPublicKey === this.toLowercaseAddress(param.sessionPublicKey) &&
                    s.sessionValidationModule === this.toLowercaseAddress(param.sessionValidationModule) &&
                    (!param.status || s.status === param.status));
            }
            else {
                return undefined;
            }
        });
        if (!session) {
            throw new Error("Session not found.");
        }
        return session;
    }
    async updateSessionStatus(param, status) {
        this.validateSearchParam(param);
        const data = this.getSessionStore();
        const session = data.leafNodes.find((s) => {
            if (param.sessionID) {
                return s.sessionID === param.sessionID;
            }
            else if (param.sessionPublicKey && param.sessionValidationModule) {
                return (s.sessionPublicKey === this.toLowercaseAddress(param.sessionPublicKey) &&
                    s.sessionValidationModule === this.toLowercaseAddress(param.sessionValidationModule));
            }
            else {
                return undefined;
            }
        });
        if (!session) {
            throw new Error("Session not found.");
        }
        session.status = status;
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async clearPendingSessions() {
        const data = this.getSessionStore();
        data.leafNodes = data.leafNodes.filter((s) => s.status !== "PENDING");
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async addSigner(signerData) {
        const signers = this.getSignerStore();
        let signer;
        if (!signerData) {
            const pkey = (0, accounts_1.generatePrivateKey)();
            signer = {
                pvKey: pkey,
                pbKey: (0, accounts_1.privateKeyToAccount)(pkey).publicKey,
            };
        }
        else {
            signer = signerData;
        }
        const accountSigner = (0, accounts_1.privateKeyToAccount)((0, viem_1.toHex)(signer.pvKey));
        const client = (0, viem_1.createWalletClient)({
            account: accountSigner,
            chain: signerData.chainId,
            transport: (0, viem_1.http)(),
        });
        const walletClientSigner = new aa_core_1.WalletClientSigner(client, "json-rpc");
        signers[this.toLowercaseAddress(accountSigner.address)] = signerData;
        localStorage.setItem(this.getStorageKey("signers"), JSON.stringify(signers));
        return walletClientSigner;
    }
    async getSignerByKey(sessionPublicKey) {
        const signers = this.getSignerStore();
        const signerData = signers[this.toLowercaseAddress(sessionPublicKey)];
        if (!signerData) {
            throw new Error("Signer not found.");
        }
        const account = (0, accounts_1.privateKeyToAccount)(signerData.privateKey);
        const client = (0, viem_1.createWalletClient)({
            account,
            chain: chains_1.mainnet,
            transport: (0, viem_1.http)(),
        });
        const signer = new aa_core_1.WalletClientSigner(client, "viem");
        return signer;
    }
    async getSignerBySession(param) {
        const session = await this.getSessionData(param);
        return this.getSignerByKey(session.sessionPublicKey);
    }
    async getAllSessionData(param) {
        const sessions = this.getSessionStore().leafNodes;
        if (!param || !param.status) {
            return sessions;
        }
        return sessions.filter((s) => s.status === param.status);
    }
    async getMerkleRoot() {
        return this.getSessionStore().merkleRoot;
    }
    setMerkleRoot(merkleRoot) {
        const data = this.getSessionStore();
        data.merkleRoot = merkleRoot;
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
        return Promise.resolve();
    }
}
exports.SessionLocalStorage = SessionLocalStorage;
//# sourceMappingURL=SessionLocalStorage.js.map