{"version":3,"file":"SessionKeyManagerModule.js","sourceRoot":"","sources":["../../src/SessionKeyManagerModule.ts"],"names":[],"mappings":"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","sourcesContent":["import { Hex, concat, encodeAbiParameters, encodeFunctionData, keccak256, pad, parseAbi, parseAbiParameters, toBytes, toHex } from \"viem\";\nimport { MerkleTree } from \"merkletreejs\";\nimport { SmartAccountSigner } from \"@alchemy/aa-core\";\nimport {\n  SessionKeyManagerModuleConfig,\n  ModuleVersion,\n  CreateSessionDataParams,\n  ModuleInfo,\n  CreateSessionDataResponse,\n  StorageType,\n} from \"./utils/Types.js\";\nimport { SESSION_MANAGER_MODULE_ADDRESSES_BY_VERSION, DEFAULT_SESSION_KEY_MANAGER_MODULE } from \"./utils/Constants.js\";\nimport { generateRandomHex } from \"./utils/Uid.js\";\nimport { BaseValidationModule } from \"./BaseValidationModule.js\";\nimport { SessionLocalStorage } from \"./session-storage/SessionLocalStorage.js\";\nimport { ISessionStorage, SessionLeafNode, SessionSearchParam, SessionStatus } from \"./interfaces/ISessionStorage.js\";\nimport { convertSigner } from \"@biconomy/common\";\n\nexport class SessionKeyManagerModule extends BaseValidationModule {\n  version: ModuleVersion = \"V1_0_0\";\n\n  moduleAddress!: Hex;\n\n  merkleTree!: MerkleTree;\n\n  sessionStorageClient!: ISessionStorage;\n\n  readonly mockEcdsaSessionKeySig: Hex =\n    \"0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b\";\n\n  /**\n   * This constructor is private. Use the static create method to instantiate SessionKeyManagerModule\n   * @param moduleConfig The configuration for the module\n   * @returns An instance of SessionKeyManagerModule\n   */\n  private constructor(moduleConfig: SessionKeyManagerModuleConfig) {\n    super(moduleConfig);\n  }\n\n  /**\n   * Asynchronously creates and initializes an instance of SessionKeyManagerModule\n   * @param moduleConfig The configuration for the module\n   * @returns A Promise that resolves to an instance of SessionKeyManagerModule\n   */\n  public static async create(moduleConfig: SessionKeyManagerModuleConfig): Promise<SessionKeyManagerModule> {\n    // TODO: (Joe) stop doing things in a 'create' call after the instance has been created\n    const instance = new SessionKeyManagerModule(moduleConfig);\n\n    if (moduleConfig.moduleAddress) {\n      instance.moduleAddress = moduleConfig.moduleAddress;\n    } else if (moduleConfig.version) {\n      const moduleAddr = SESSION_MANAGER_MODULE_ADDRESSES_BY_VERSION[moduleConfig.version] as Hex;\n      if (!moduleAddr) {\n        throw new Error(`Invalid version ${moduleConfig.version}`);\n      }\n      instance.moduleAddress = moduleAddr;\n      instance.version = moduleConfig.version as ModuleVersion;\n    } else {\n      instance.moduleAddress = DEFAULT_SESSION_KEY_MANAGER_MODULE;\n      // Note: in this case Version remains the default one\n    }\n\n    if (moduleConfig.sessionStorageClient) {\n      instance.sessionStorageClient = moduleConfig.sessionStorageClient;\n    } else {\n      switch (moduleConfig.storageType) {\n        case StorageType.LOCAL_STORAGE:\n          instance.sessionStorageClient = new SessionLocalStorage(moduleConfig.smartAccountAddress);\n          break;\n        default:\n          instance.sessionStorageClient = new SessionLocalStorage(moduleConfig.smartAccountAddress);\n      }\n    }\n\n    const existingSessionData = await instance.sessionStorageClient.getAllSessionData();\n    const existingSessionDataLeafs = existingSessionData.map((sessionData) => {\n      const leafDataHex = concat([\n        pad(toHex(sessionData.validUntil), { size: 6 }),\n        pad(toHex(sessionData.validAfter), { size: 6 }),\n        pad(sessionData.sessionValidationModule, { size: 20 }),\n        sessionData.sessionKeyData,\n      ]);\n      return keccak256(leafDataHex);\n    });\n\n    instance.merkleTree = new MerkleTree(existingSessionDataLeafs, keccak256, {\n      sortPairs: true,\n      hashLeaves: false,\n    });\n\n    return instance;\n  }\n\n  /**\n   * Method to create session data for any module. The session data is used to create a leaf in the merkle tree\n   * @param leavesData The data of one or more leaves to be used to create session data\n   * @returns The session data\n   */\n  createSessionData = async (leavesData: CreateSessionDataParams[]): Promise<CreateSessionDataResponse> => {\n    const sessionKeyManagerModuleABI = parseAbi([\"function setMerkleRoot(bytes32 _merkleRoot)\"]);\n\n    const leavesToAdd: Buffer[] = [];\n    const sessionIDInfo: string[] = [];\n\n    for (const leafData of leavesData) {\n      const leafDataHex = concat([\n        pad(toHex(leafData.validUntil), { size: 6 }),\n        pad(toHex(leafData.validAfter), { size: 6 }),\n        pad(leafData.sessionValidationModule, { size: 20 }),\n        leafData.sessionKeyData,\n      ]);\n\n      const generatedSessionId = leafData.preferredSessionId ?? generateRandomHex();\n\n      // TODO: verify this, might not be buffer\n      leavesToAdd.push(keccak256(leafDataHex) as unknown as Buffer);\n      sessionIDInfo.push(generatedSessionId);\n\n      const sessionLeafNode = {\n        ...leafData,\n        sessionID: generatedSessionId,\n        status: \"PENDING\" as SessionStatus,\n      };\n\n      await this.sessionStorageClient.addSessionData(sessionLeafNode);\n    }\n\n    this.merkleTree.addLeaves(leavesToAdd);\n\n    const leaves = this.merkleTree.getLeaves();\n\n    const newMerkleTree = new MerkleTree(leaves, keccak256, {\n      sortPairs: true,\n      hashLeaves: false,\n    });\n\n    this.merkleTree = newMerkleTree;\n\n    const setMerkleRootData = encodeFunctionData({\n      abi: sessionKeyManagerModuleABI,\n      functionName: \"setMerkleRoot\",\n      args: [this.merkleTree.getHexRoot() as Hex],\n    });\n\n    await this.sessionStorageClient.setMerkleRoot(this.merkleTree.getHexRoot());\n    return {\n      data: setMerkleRootData,\n      sessionIDInfo: sessionIDInfo,\n    };\n  };\n\n  /**\n   * This method is used to sign the user operation using the session signer\n   * @param userOp The user operation to be signed\n   * @param sessionSigner The signer to be used to sign the user operation\n   * @returns The signature of the user operation\n   */\n  async signUserOpHash(userOpHash: string, params?: ModuleInfo): Promise<Hex> {\n    if (!(params && params.sessionSigner)) {\n      throw new Error(\"Session signer is not provided.\");\n    }\n    const { signer: sessionSigner } = await convertSigner(params.sessionSigner);\n\n    // Use the sessionSigner to sign the user operation\n    const signature = await sessionSigner.signMessage(toBytes(userOpHash));\n\n    const sessionSignerData = await this.getLeafInfo(params);\n\n    const leafDataHex = concat([\n      pad(toHex(sessionSignerData.validUntil), { size: 6 }),\n      pad(toHex(sessionSignerData.validAfter), { size: 6 }),\n      pad(sessionSignerData.sessionValidationModule, { size: 20 }),\n      sessionSignerData.sessionKeyData,\n    ]);\n\n    // Generate the padded signature with (validUntil,validAfter,sessionVerificationModuleAddress,validationData,merkleProof,signature)\n    let paddedSignature: Hex = encodeAbiParameters(parseAbiParameters(\"uint48, uint48, address, bytes, bytes32[], bytes\"), [\n      sessionSignerData.validUntil,\n      sessionSignerData.validAfter,\n      sessionSignerData.sessionValidationModule,\n      sessionSignerData.sessionKeyData,\n      this.merkleTree.getHexProof(keccak256(leafDataHex)) as Hex[],\n      signature,\n    ]);\n\n    if (params?.additionalSessionData) {\n      paddedSignature += params.additionalSessionData;\n    }\n\n    return paddedSignature as Hex;\n  }\n\n  private async getLeafInfo(params: ModuleInfo): Promise<SessionLeafNode> {\n    if (!(params && params.sessionSigner)) {\n      throw new Error(\"Session signer is not provided.\");\n    }\n    const { signer: sessionSigner } = await convertSigner(params.sessionSigner);\n    let sessionSignerData;\n    if (params?.sessionID) {\n      sessionSignerData = await this.sessionStorageClient.getSessionData({\n        sessionID: params.sessionID,\n      });\n    } else if (params?.sessionValidationModule) {\n      sessionSignerData = await this.sessionStorageClient.getSessionData({\n        sessionValidationModule: params.sessionValidationModule,\n        sessionPublicKey: await sessionSigner.getAddress(),\n      });\n    } else {\n      throw new Error(\"sessionID or sessionValidationModule should be provided.\");\n    }\n\n    return sessionSignerData;\n  }\n\n  /**\n   * Update the session data pending state to active\n   * @param param The search param to find the session data\n   * @param status The status to be updated\n   * @returns\n   */\n  async updateSessionStatus(param: SessionSearchParam, status: SessionStatus): Promise<void> {\n    this.sessionStorageClient.updateSessionStatus(param, status);\n  }\n\n  /**\n   * @remarks This method is used to clear all the pending sessions\n   * @returns\n   */\n  async clearPendingSessions(): Promise<void> {\n    this.sessionStorageClient.clearPendingSessions();\n  }\n\n  /**\n   * @returns SessionKeyManagerModule address\n   */\n  getAddress(): Hex {\n    return this.moduleAddress;\n  }\n\n  /**\n   * @remarks This is the version of the module contract\n   */\n  async getSigner(): Promise<SmartAccountSigner> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * @remarks This is the dummy signature for the module, used in buildUserOp for bundler estimation\n   * @returns Dummy signature\n   */\n  async getDummySignature(params?: ModuleInfo): Promise<Hex> {\n    if (!params) {\n      throw new Error(\"Session signer is not provided.\");\n    }\n    const sessionSignerData = await this.getLeafInfo(params);\n    const leafDataHex = concat([\n      pad(toHex(sessionSignerData.validUntil), { size: 6 }),\n      pad(toHex(sessionSignerData.validAfter), { size: 6 }),\n      pad(sessionSignerData.sessionValidationModule, { size: 20 }),\n      sessionSignerData.sessionKeyData,\n    ]);\n\n    // Generate the padded signature with (validUntil,validAfter,sessionVerificationModuleAddress,validationData,merkleProof,signature)\n    let paddedSignature: Hex = encodeAbiParameters(parseAbiParameters(\"uint48, uint48, address, bytes, bytes32[], bytes\"), [\n      sessionSignerData.validUntil,\n      sessionSignerData.validAfter,\n      sessionSignerData.sessionValidationModule,\n      sessionSignerData.sessionKeyData,\n      this.merkleTree.getHexProof(keccak256(leafDataHex)) as Hex[],\n      this.mockEcdsaSessionKeySig,\n    ]);\n    if (params?.additionalSessionData) {\n      paddedSignature += params.additionalSessionData;\n    }\n\n    const dummySig = encodeAbiParameters(parseAbiParameters([\"bytes, address\"]), [paddedSignature as Hex, this.getAddress()]);\n\n    return dummySig;\n  }\n\n  /**\n   * @remarks Other modules may need additional attributes to build init data\n   */\n  async getInitData(): Promise<Hex> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * @remarks This Module dont have knowledge of signer. So, this method is not implemented\n   */\n  async signMessage(_message: Uint8Array | string): Promise<string> {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n"]}