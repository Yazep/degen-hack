{"version":3,"file":"MultichainValidationModule.js","sourceRoot":"","sources":["../../src/MultichainValidationModule.ts"],"names":[],"mappings":"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","sourcesContent":["import { Hex, concat, encodeAbiParameters, encodeFunctionData, getAddress, keccak256, pad, parseAbi, parseAbiParameters, toBytes, toHex } from \"viem\";\nimport { UserOperationStruct, SmartAccountSigner } from \"@alchemy/aa-core\";\nimport { MerkleTree } from \"merkletreejs\";\nimport { DEFAULT_MULTICHAIN_MODULE, MULTICHAIN_VALIDATION_MODULE_ADDRESSES_BY_VERSION } from \"./utils/Constants.js\";\nimport {\n  ModuleVersion,\n  MultiChainUserOpDto,\n  MultiChainValidationModuleConfig,\n  MultiChainValidationModuleConfigConstructorProps,\n} from \"./utils/Types.js\";\nimport { BaseValidationModule } from \"./BaseValidationModule.js\";\nimport { getUserOpHash } from \"./utils/Helper.js\";\nimport { convertSigner, Logger } from \"@biconomy/common\";\n\nexport class MultiChainValidationModule extends BaseValidationModule {\n  signer: SmartAccountSigner;\n\n  moduleAddress!: Hex;\n\n  version: ModuleVersion = \"V1_0_0\";\n\n  private constructor(moduleConfig: MultiChainValidationModuleConfigConstructorProps) {\n    super(moduleConfig);\n    this.signer = moduleConfig.signer;\n  }\n\n  public static async create(moduleConfig: MultiChainValidationModuleConfig): Promise<MultiChainValidationModule> {\n    // Signer needs to be initialised here before defaultValidationModule is set\n    const { signer } = await convertSigner(moduleConfig.signer, true);\n    const configForConstructor: MultiChainValidationModuleConfigConstructorProps = { ...moduleConfig, signer };\n\n    // TODO: (Joe) stop doing things in a 'create' call after the instance has been created\n    const instance = new MultiChainValidationModule(configForConstructor);\n    if (moduleConfig.moduleAddress) {\n      instance.moduleAddress = moduleConfig.moduleAddress;\n    } else if (moduleConfig.version) {\n      const moduleAddr = MULTICHAIN_VALIDATION_MODULE_ADDRESSES_BY_VERSION[moduleConfig.version] as Hex;\n      if (!moduleAddr) {\n        throw new Error(`Invalid version ${moduleConfig.version}`);\n      }\n      instance.moduleAddress = moduleAddr;\n      instance.version = moduleConfig.version as ModuleVersion;\n    } else {\n      instance.moduleAddress = DEFAULT_MULTICHAIN_MODULE;\n      // Note: in this case Version remains the default one\n    }\n    return instance;\n  }\n\n  getAddress(): Hex {\n    return this.moduleAddress;\n  }\n\n  async getSigner(): Promise<SmartAccountSigner> {\n    return Promise.resolve(this.signer);\n  }\n\n  async getDummySignature(): Promise<Hex> {\n    const moduleAddress = getAddress(this.getAddress());\n    const dynamicPart = moduleAddress.substring(2).padEnd(40, \"0\");\n    return `0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000${dynamicPart}000000000000000000000000000000000000000000000000000000000000004181d4b4981670cb18f99f0b4a66446df1bf5b204d24cfcb659bf38ba27a4359b5711649ec2423c5e1247245eba2964679b6a1dbb85c992ae40b9b00c6935b02ff1b00000000000000000000000000000000000000000000000000000000000000`;\n  }\n\n  // Note: other modules may need additional attributes to build init data\n  async getInitData(): Promise<Hex> {\n    const ecdsaOwnerAddress = await this.signer.getAddress();\n    const moduleRegistryParsedAbi = parseAbi([\"function initForSmartAccount(address owner)\"]);\n    const ecdsaOwnershipInitData = encodeFunctionData({\n      abi: moduleRegistryParsedAbi,\n      functionName: \"initForSmartAccount\",\n      args: [ecdsaOwnerAddress],\n    });\n    return ecdsaOwnershipInitData;\n  }\n\n  async signUserOpHash(userOpHash: string): Promise<Hex> {\n    const sig = await this.signer.signMessage(toBytes(userOpHash));\n    return sig;\n  }\n\n  /**\n   * Signs a message using the appropriate method based on the type of signer.\n   *\n   * @param {Uint8Array | string} message - The message to be signed.\n   * @returns {Promise<string>} A promise resolving to the signature or error message.\n   * @throws {Error} If the signer type is invalid or unsupported.\n   */\n  async signMessage(message: Uint8Array | string): Promise<string> {\n    let signature = await this.signer.signMessage(message);\n\n    const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);\n    if (![27, 28].includes(potentiallyIncorrectV)) {\n      const correctV = potentiallyIncorrectV + 27;\n      signature = signature.slice(0, -2) + correctV.toString(16);\n    }\n    return signature;\n  }\n\n  async signUserOps(multiChainUserOps: MultiChainUserOpDto[]): Promise<UserOperationStruct[]> {\n    try {\n      const leaves: string[] = [];\n\n      // Iterate over each userOp and process them\n      for (const multiChainOp of multiChainUserOps) {\n        const validUntil = multiChainOp.validUntil ?? 0;\n        const validAfter = multiChainOp.validAfter ?? 0;\n        const leaf = concat([\n          pad(toHex(validUntil), { size: 6 }),\n          pad(toHex(validAfter), { size: 6 }),\n          pad(getUserOpHash(multiChainOp.userOp, this.entryPointAddress, multiChainOp.chainId), { size: 32 }),\n        ]);\n\n        leaves.push(keccak256(leaf));\n      }\n\n      // Create a new Merkle tree using the leaves array\n      const merkleTree = new MerkleTree(leaves, keccak256, { sortPairs: true });\n\n      let multichainSignature = await this.signer.signMessage(toBytes(merkleTree.getHexRoot()));\n\n      const potentiallyIncorrectV = parseInt(multichainSignature.slice(-2), 16);\n      if (![27, 28].includes(potentiallyIncorrectV)) {\n        const correctV = potentiallyIncorrectV + 27;\n        multichainSignature = multichainSignature.slice(0, -2) + correctV.toString(16);\n      }\n\n      // Create an array to store updated userOps\n      const updatedUserOps: UserOperationStruct[] = [];\n\n      for (let i = 0; i < leaves.length; i++) {\n        const merkleProof = merkleTree.getHexProof(leaves[i]);\n\n        const validUntil = multiChainUserOps[i].validUntil ?? 0;\n        const validAfter = multiChainUserOps[i].validAfter ?? 0;\n\n        // Create the moduleSignature\n        const moduleSignature = encodeAbiParameters(parseAbiParameters([\"uint48, uint48, bytes32, bytes32[], bytes\"]), [\n          validUntil,\n          validAfter,\n          merkleTree.getHexRoot() as Hex,\n          merkleProof as Hex[],\n          multichainSignature as Hex,\n        ]);\n\n        // Note: Because accountV2 does not directly call this method. hence we need to add validation module address to the signature\n        const signatureWithModuleAddress = encodeAbiParameters(parseAbiParameters([\"bytes, address\"]), [moduleSignature, this.getAddress()]);\n\n        // Update userOp with the final signature\n        const updatedUserOp: UserOperationStruct = {\n          ...(multiChainUserOps[i].userOp as UserOperationStruct),\n          signature: signatureWithModuleAddress as `0x${string}`,\n        };\n\n        updatedUserOps.push(updatedUserOp);\n      }\n      return updatedUserOps;\n    } catch (error) {\n      Logger.error(\"Error in signing multi chain userops\");\n      throw new Error(JSON.stringify(error));\n    }\n  }\n}\n"]}