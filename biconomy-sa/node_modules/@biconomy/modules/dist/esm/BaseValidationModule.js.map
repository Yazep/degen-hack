{"version":3,"file":"BaseValidationModule.js","sourceRoot":"","sources":["../../src/BaseValidationModule.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,0BAA0B,EAAE,MAAM,sBAAsB,CAAC;AAGlE,MAAM,OAAgB,oBAAoB;IAGxC,YAAY,YAAwC;QAFpD;;;;;WAAuB;QAGrB,MAAM,EAAE,iBAAiB,EAAE,GAAG,YAAY,CAAC;QAE3C,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,IAAI,0BAA0B,CAAC;IAC3E,CAAC;IAID,oBAAoB,CAAC,iBAAsB;QACzC,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;IAC7C,CAAC;IAcD,KAAK,CAAC,6BAA6B,CAAC,OAA4B,EAAE,MAA0B;QAC1F,IAAI,SAAS,GAAkB,MAAM,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QAEjE,MAAM,qBAAqB,GAAG,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QAChE,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,QAAQ,CAAC,qBAAqB,CAAC,EAAE,CAAC;YAC9C,MAAM,QAAQ,GAAG,qBAAqB,GAAG,EAAE,CAAC;YAC5C,SAAS,GAAG,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;QACpE,CAAC;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;CACF","sourcesContent":["import { Hex } from \"viem\";\nimport { SmartAccountSigner } from \"@alchemy/aa-core\";\nimport { BaseValidationModuleConfig, ModuleInfo } from \"./utils/Types.js\";\nimport { DEFAULT_ENTRYPOINT_ADDRESS } from \"./utils/Constants.js\";\nimport { IValidationModule } from \"./interfaces/IValidationModule.js\";\n\nexport abstract class BaseValidationModule implements IValidationModule {\n  entryPointAddress: Hex;\n\n  constructor(moduleConfig: BaseValidationModuleConfig) {\n    const { entryPointAddress } = moduleConfig;\n\n    this.entryPointAddress = entryPointAddress || DEFAULT_ENTRYPOINT_ADDRESS;\n  }\n\n  abstract getAddress(): Hex;\n\n  setEntryPointAddress(entryPointAddress: Hex): void {\n    this.entryPointAddress = entryPointAddress;\n  }\n\n  abstract getInitData(): Promise<Hex>;\n\n  // Anything  required to get dummy signature can be passed as params\n  abstract getDummySignature(_params?: ModuleInfo): Promise<Hex>;\n\n  abstract getSigner(): Promise<SmartAccountSigner>;\n\n  // Signer specific or any other additional information can be passed as params\n  abstract signUserOpHash(_userOpHash: string, _params?: ModuleInfo): Promise<Hex>;\n\n  abstract signMessage(_message: Uint8Array | string): Promise<string>;\n\n  async signMessageSmartAccountSigner(message: string | Uint8Array, signer: SmartAccountSigner): Promise<string> {\n    let signature: `0x${string}` = await signer.signMessage(message);\n\n    const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);\n    if (![27, 28].includes(potentiallyIncorrectV)) {\n      const correctV = potentiallyIncorrectV + 27;\n      signature = `0x${signature.slice(0, -2) + correctV.toString(16)}`;\n    }\n\n    return signature;\n  }\n}\n"]}