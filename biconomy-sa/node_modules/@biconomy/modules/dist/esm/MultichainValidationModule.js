"use strict";import{concat as v,encodeAbiParameters as l,encodeFunctionData as y,getAddress as w,keccak256 as g,pad as d,parseAbi as I,parseAbiParameters as b,toBytes as A,toHex as f}from"viem";import{MerkleTree as O}from"merkletreejs";import{DEFAULT_MULTICHAIN_MODULE as S,MULTICHAIN_VALIDATION_MODULE_ADDRESSES_BY_VERSION as P}from"./utils/Constants.js";import{BaseValidationModule as D}from"./BaseValidationModule.js";import{getUserOpHash as M}from"./utils/Helper.js";import{convertSigner as U,Logger as E}from"@biconomy/common";export class MultiChainValidationModule extends D{constructor(e){super(e),Object.defineProperty(this,"signer",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"moduleAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:"V1_0_0"}),this.signer=e.signer}static async create(e){const{signer:r}=await U(e.signer,!0),n={...e,signer:r},s=new MultiChainValidationModule(n);if(e.moduleAddress)s.moduleAddress=e.moduleAddress;else if(e.version){const i=P[e.version];if(!i)throw new Error(`Invalid version ${e.version}`);s.moduleAddress=i,s.version=e.version}else s.moduleAddress=S;return s}getAddress(){return this.moduleAddress}async getSigner(){return Promise.resolve(this.signer)}async getDummySignature(){return`0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000${w(this.getAddress()).substring(2).padEnd(40,"0")}000000000000000000000000000000000000000000000000000000000000004181d4b4981670cb18f99f0b4a66446df1bf5b204d24cfcb659bf38ba27a4359b5711649ec2423c5e1247245eba2964679b6a1dbb85c992ae40b9b00c6935b02ff1b00000000000000000000000000000000000000000000000000000000000000`}async getInitData(){const e=await this.signer.getAddress(),r=I(["function initForSmartAccount(address owner)"]);return y({abi:r,functionName:"initForSmartAccount",args:[e]})}async signUserOpHash(e){return await this.signer.signMessage(A(e))}async signMessage(e){let r=await this.signer.signMessage(e);const n=parseInt(r.slice(-2),16);if(![27,28].includes(n)){const s=n+27;r=r.slice(0,-2)+s.toString(16)}return r}async signUserOps(e){try{const r=[];for(const t of e){const a=t.validUntil??0,o=t.validAfter??0,c=v([d(f(a),{size:6}),d(f(o),{size:6}),d(M(t.userOp,this.entryPointAddress,t.chainId),{size:32})]);r.push(g(c))}const n=new O(r,g,{sortPairs:!0});let s=await this.signer.signMessage(A(n.getHexRoot()));const i=parseInt(s.slice(-2),16);if(![27,28].includes(i)){const t=i+27;s=s.slice(0,-2)+t.toString(16)}const u=[];for(let t=0;t<r.length;t++){const a=n.getHexProof(r[t]),o=e[t].validUntil??0,c=e[t].validAfter??0,m=l(b(["uint48, uint48, bytes32, bytes32[], bytes"]),[o,c,n.getHexRoot(),a,s]),p=l(b(["bytes, address"]),[m,this.getAddress()]),h={...e[t].userOp,signature:p};u.push(h)}return u}catch(r){throw E.error("Error in signing multi chain userops"),new Error(JSON.stringify(r))}}}
