"use strict";import{BATCHED_SESSION_ROUTER_MODULE_ADDRESSES_BY_VERSION as b,DEFAULT_SESSION_KEY_MANAGER_MODULE as m,DEFAULT_BATCHED_SESSION_ROUTER_MODULE as A}from"./utils/Constants.js";import{BaseValidationModule as D}from"./BaseValidationModule.js";import{SessionKeyManagerModule as f}from"./SessionKeyManagerModule.js";import{concat as M,encodeAbiParameters as w,keccak256 as S,pad as t,parseAbiParameters as v,toBytes as E,toHex as u}from"viem";import{convertSigner as y}from"@biconomy/common";import{defaultAbiCoder as p}from"@ethersproject/abi";export class BatchedSessionRouterModule extends D{constructor(e){super(e),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:"V1_0_0"}),Object.defineProperty(this,"moduleAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"sessionManagerModuleAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"sessionKeyManagerModule",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"mockEcdsaSessionKeySig",{enumerable:!0,configurable:!0,writable:!0,value:"0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b"}),Object.defineProperty(this,"createSessionData",{enumerable:!0,configurable:!0,writable:!0,value:async s=>this.sessionKeyManagerModule.createSessionData(s)})}static async create(e){const s=new BatchedSessionRouterModule(e);if(e.moduleAddress)s.moduleAddress=e.moduleAddress;else if(e.version){const n=b[e.version];if(!n)throw new Error(`Invalid version ${e.version}`);s.moduleAddress=n,s.version=e.version}else s.moduleAddress=A;if(s.sessionManagerModuleAddress=e.sessionManagerModuleAddress??m,e.sessionKeyManagerModule)s.sessionKeyManagerModule=e.sessionKeyManagerModule,s.sessionManagerModuleAddress=e.sessionKeyManagerModule.getAddress();else{const n=await f.create({moduleAddress:s.sessionManagerModuleAddress,smartAccountAddress:e.smartAccountAddress,nodeClientUrl:e.nodeClientUrl,storageType:e.storageType});s.sessionKeyManagerModule=n}return s}async signUserOpHash(e,s){const n=s?.batchSessionParams;if(!n||n.length===0)throw new Error("Session parameters are not provided");const d=[],{signer:l}=await y(n[0].sessionSigner),g=await l.signMessage(E(e));for(const i of n){if(!i.sessionSigner)throw new Error("Session signer is not provided.");const a=[];let r;if(i.sessionID)r=await this.sessionKeyManagerModule.sessionStorageClient.getSessionData({sessionID:i.sessionID});else if(i.sessionValidationModule)r=await this.sessionKeyManagerModule.sessionStorageClient.getSessionData({sessionValidationModule:i.sessionValidationModule,sessionPublicKey:await l.getAddress()});else throw new Error("sessionID or sessionValidationModule should be provided.");a.push(r.validUntil),a.push(r.validAfter),a.push(r.sessionValidationModule),a.push(r.sessionKeyData);const c=M([t(u(r.validUntil),{size:6}),t(u(r.validAfter),{size:6}),t(r.sessionValidationModule,{size:20}),r.sessionKeyData]),h=this.sessionKeyManagerModule.merkleTree.getHexProof(S(c));a.push(h),a.push(i.additionalSessionData??"0x"),d.push(a)}return p.encode(["address","tuple(uint48,uint48,address,bytes,bytes32[],bytes)[]","bytes"],[this.getSessionKeyManagerAddress(),d,g])}async updateSessionStatus(e,s){this.sessionKeyManagerModule.sessionStorageClient.updateSessionStatus(e,s)}async clearPendingSessions(){this.sessionKeyManagerModule.sessionStorageClient.clearPendingSessions()}getAddress(){return this.moduleAddress}getSessionKeyManagerAddress(){return this.sessionManagerModuleAddress}async getSigner(){throw new Error("Method not implemented.")}async getDummySignature(e){const s=e?.batchSessionParams;if(!s||s.length===0)throw new Error("Session parameters are not provided");const n=[],{signer:d}=await y(s[0].sessionSigner);for(const o of s){if(!o.sessionSigner)throw new Error("Session signer is not provided.");const i=[];let a;if(o.sessionID)a=await this.sessionKeyManagerModule.sessionStorageClient.getSessionData({sessionID:o.sessionID});else if(o.sessionValidationModule)a=await this.sessionKeyManagerModule.sessionStorageClient.getSessionData({sessionValidationModule:o.sessionValidationModule,sessionPublicKey:await d.getAddress()});else throw new Error("sessionID or sessionValidationModule should be provided.");i.push(BigInt(a.validUntil)),i.push(BigInt(a.validAfter)),i.push(a.sessionValidationModule),i.push(a.sessionKeyData);const r=M([t(u(a.validUntil),{size:6}),t(u(a.validAfter),{size:6}),t(a.sessionValidationModule,{size:20}),a.sessionKeyData]),c=this.sessionKeyManagerModule.merkleTree.getHexProof(S(r));i.push(c),i.push(o.additionalSessionData??"0x"),n.push(i)}const l=p.encode(["address","tuple(uint48,uint48,address,bytes,bytes32[],bytes)[]","bytes"],[this.getSessionKeyManagerAddress(),n,this.mockEcdsaSessionKeySig]);return w(v("bytes, address"),[l,this.getAddress()])}async getInitData(){throw new Error("Method not implemented.")}async signMessage(e){throw new Error("Method not implemented.")}}
