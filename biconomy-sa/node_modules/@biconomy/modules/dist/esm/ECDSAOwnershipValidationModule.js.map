{"version":3,"file":"ECDSAOwnershipValidationModule.js","sourceRoot":"","sources":["../../src/ECDSAOwnershipValidationModule.ts"],"names":[],"mappings":"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","sourcesContent":["import { Hex, encodeFunctionData, getAddress, parseAbi, toBytes } from \"viem\";\nimport { SmartAccountSigner } from \"@alchemy/aa-core\";\nimport { ECDSAOwnershipValidationModuleConfig, ECDSAOwnershipValidationModuleConfigConstructorProps, ModuleVersion } from \"./utils/Types.js\";\nimport { DEFAULT_ECDSA_OWNERSHIP_MODULE, ECDSA_OWNERSHIP_MODULE_ADDRESSES_BY_VERSION } from \"./utils/Constants.js\";\nimport { convertSigner } from \"@biconomy/common\";\nimport { BaseValidationModule } from \"./BaseValidationModule.js\";\n\n// Could be renamed with suffix API\nexport class ECDSAOwnershipValidationModule extends BaseValidationModule {\n  signer: SmartAccountSigner;\n\n  moduleAddress!: Hex;\n\n  version: ModuleVersion = \"V1_0_0\";\n\n  private constructor(moduleConfig: ECDSAOwnershipValidationModuleConfigConstructorProps) {\n    super(moduleConfig);\n    this.signer = moduleConfig.signer;\n  }\n\n  public static async create(moduleConfig: ECDSAOwnershipValidationModuleConfig): Promise<ECDSAOwnershipValidationModule> {\n    // Signer needs to be initialised here before defaultValidationModule is set\n    const { signer } = await convertSigner(moduleConfig.signer, true);\n    const configForConstructor: ECDSAOwnershipValidationModuleConfigConstructorProps = { ...moduleConfig, signer };\n\n    // TODO: (Joe) stop doing things in a 'create' call after the instance has been created\n    const instance = new ECDSAOwnershipValidationModule(configForConstructor);\n    if (moduleConfig.moduleAddress) {\n      instance.moduleAddress = moduleConfig.moduleAddress;\n    } else if (moduleConfig.version) {\n      const moduleAddr = ECDSA_OWNERSHIP_MODULE_ADDRESSES_BY_VERSION[moduleConfig.version] as Hex;\n      if (!moduleAddr) {\n        throw new Error(`Invalid version ${moduleConfig.version}`);\n      }\n      instance.moduleAddress = moduleAddr;\n      instance.version = moduleConfig.version as ModuleVersion;\n    } else {\n      instance.moduleAddress = DEFAULT_ECDSA_OWNERSHIP_MODULE;\n      // Note: in this case Version remains the default one\n    }\n    return instance;\n  }\n\n  getAddress(): Hex {\n    return this.moduleAddress;\n  }\n\n  async getSigner(): Promise<SmartAccountSigner> {\n    return Promise.resolve(this.signer);\n  }\n\n  async getDummySignature(): Promise<Hex> {\n    const moduleAddress = getAddress(this.getAddress());\n    const dynamicPart = moduleAddress.substring(2).padEnd(40, \"0\");\n    return `0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000${dynamicPart}000000000000000000000000000000000000000000000000000000000000004181d4b4981670cb18f99f0b4a66446df1bf5b204d24cfcb659bf38ba27a4359b5711649ec2423c5e1247245eba2964679b6a1dbb85c992ae40b9b00c6935b02ff1b00000000000000000000000000000000000000000000000000000000000000`;\n  }\n\n  // Note: other modules may need additional attributes to build init data\n  async getInitData(): Promise<Hex> {\n    const ecdsaOwnerAddress = await this.signer.getAddress();\n    const moduleRegistryParsedAbi = parseAbi([\"function initForSmartAccount(address owner)\"]);\n    const ecdsaOwnershipInitData = encodeFunctionData({\n      abi: moduleRegistryParsedAbi,\n      functionName: \"initForSmartAccount\",\n      args: [ecdsaOwnerAddress],\n    });\n    return ecdsaOwnershipInitData;\n  }\n\n  async signUserOpHash(userOpHash: string): Promise<Hex> {\n    const sig = await this.signer.signMessage(toBytes(userOpHash));\n    return sig;\n  }\n\n  /**\n   * Signs a message using the appropriate method based on the type of signer.\n   *\n   * @param {Uint8Array | string} message - The message to be signed.\n   * @returns {Promise<string>} A promise resolving to the signature or error message.\n   * @throws {Error} If the signer type is invalid or unsupported.\n   */\n  async signMessage(message: Uint8Array | string): Promise<string> {\n    let signature = await this.signer.signMessage(message);\n\n    const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);\n    if (![27, 28].includes(potentiallyIncorrectV)) {\n      const correctV = potentiallyIncorrectV + 27;\n      signature = signature.slice(0, -2) + correctV.toString(16);\n    }\n    return signature;\n  }\n}\n"]}