{"version":3,"file":"BatchedSessionRouterModule.js","sourceRoot":"","sources":["../../src/BatchedSessionRouterModule.ts"],"names":[],"mappings":"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","sourcesContent":["import { ModuleVersion, CreateSessionDataParams, BatchedSessionRouterModuleConfig, ModuleInfo, CreateSessionDataResponse } from \"./utils/Types.js\";\nimport {\n  BATCHED_SESSION_ROUTER_MODULE_ADDRESSES_BY_VERSION,\n  DEFAULT_SESSION_KEY_MANAGER_MODULE,\n  DEFAULT_BATCHED_SESSION_ROUTER_MODULE,\n} from \"./utils/Constants.js\";\nimport { BaseValidationModule } from \"./BaseValidationModule.js\";\nimport { SessionKeyManagerModule } from \"./SessionKeyManagerModule.js\";\nimport { SessionSearchParam, SessionStatus } from \"./interfaces/ISessionStorage.js\";\nimport { Hex, concat, encodeAbiParameters, keccak256, pad, parseAbiParameters, toBytes, toHex } from \"viem\";\nimport { SmartAccountSigner } from \"@alchemy/aa-core\";\nimport { convertSigner } from \"@biconomy/common\";\nimport { defaultAbiCoder } from \"@ethersproject/abi\";\n\nexport class BatchedSessionRouterModule extends BaseValidationModule {\n  version: ModuleVersion = \"V1_0_0\";\n\n  moduleAddress!: Hex;\n\n  sessionManagerModuleAddress!: Hex;\n\n  sessionKeyManagerModule!: SessionKeyManagerModule;\n\n  readonly mockEcdsaSessionKeySig: Hex =\n    \"0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b\";\n\n  /**\n   * This constructor is private. Use the static create method to instantiate SessionKeyManagerModule\n   * @param moduleConfig The configuration for the module\n   * @returns An instance of SessionKeyManagerModule\n   */\n  private constructor(moduleConfig: BatchedSessionRouterModuleConfig) {\n    super(moduleConfig);\n  }\n\n  /**\n   * Asynchronously creates and initializes an instance of SessionKeyManagerModule\n   * @param moduleConfig The configuration for the module\n   * @returns A Promise that resolves to an instance of SessionKeyManagerModule\n   */\n  public static async create(moduleConfig: BatchedSessionRouterModuleConfig): Promise<BatchedSessionRouterModule> {\n    const instance = new BatchedSessionRouterModule(moduleConfig);\n\n    if (moduleConfig.moduleAddress) {\n      instance.moduleAddress = moduleConfig.moduleAddress;\n    } else if (moduleConfig.version) {\n      const moduleAddr = BATCHED_SESSION_ROUTER_MODULE_ADDRESSES_BY_VERSION[moduleConfig.version] as Hex;\n      if (!moduleAddr) {\n        throw new Error(`Invalid version ${moduleConfig.version}`);\n      }\n      instance.moduleAddress = moduleAddr;\n      instance.version = moduleConfig.version as ModuleVersion;\n    } else {\n      instance.moduleAddress = DEFAULT_BATCHED_SESSION_ROUTER_MODULE;\n      // Note: in this case Version remains the default one\n    }\n\n    instance.sessionManagerModuleAddress = moduleConfig.sessionManagerModuleAddress ?? DEFAULT_SESSION_KEY_MANAGER_MODULE;\n\n    if (!moduleConfig.sessionKeyManagerModule) {\n      // generate sessionModule\n      const sessionModule = await SessionKeyManagerModule.create({\n        moduleAddress: instance.sessionManagerModuleAddress,\n        smartAccountAddress: moduleConfig.smartAccountAddress,\n        nodeClientUrl: moduleConfig.nodeClientUrl,\n        storageType: moduleConfig.storageType,\n      });\n\n      instance.sessionKeyManagerModule = sessionModule;\n    } else {\n      instance.sessionKeyManagerModule = moduleConfig.sessionKeyManagerModule;\n      instance.sessionManagerModuleAddress = moduleConfig.sessionKeyManagerModule.getAddress();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Method to create session data for any module. The session data is used to create a leaf in the merkle tree\n   * @param leavesData The data of one or more leaves to be used to create session data\n   * @returns The session data\n   */\n  createSessionData = async (leavesData: CreateSessionDataParams[]): Promise<CreateSessionDataResponse> => {\n    return this.sessionKeyManagerModule.createSessionData(leavesData);\n  };\n\n  /**\n   * This method is used to sign the user operation using the session signer\n   * @param userOp The user operation to be signed\n   * @param sessionParams Information about all the sessions to be used to sign the user operation which has a batch execution\n   * @returns The signature of the user operation\n   */\n  async signUserOpHash(userOpHash: string, params?: ModuleInfo): Promise<Hex> {\n    const sessionParams = params?.batchSessionParams;\n    if (!sessionParams || sessionParams.length === 0) {\n      throw new Error(\"Session parameters are not provided\");\n    }\n\n    const sessionDataTupleArray = [];\n\n    // signer must be the same for all the sessions\n    const { signer: sessionSigner } = await convertSigner(sessionParams[0].sessionSigner);\n\n    const signature = await sessionSigner.signMessage(toBytes(userOpHash));\n\n    for (const sessionParam of sessionParams) {\n      if (!sessionParam.sessionSigner) {\n        throw new Error(\"Session signer is not provided.\");\n      }\n\n      const sessionDataTuple = [];\n\n      let sessionSignerData;\n\n      if (sessionParam.sessionID) {\n        sessionSignerData = await this.sessionKeyManagerModule.sessionStorageClient.getSessionData({\n          sessionID: sessionParam.sessionID,\n        });\n      } else if (sessionParam.sessionValidationModule) {\n        sessionSignerData = await this.sessionKeyManagerModule.sessionStorageClient.getSessionData({\n          sessionValidationModule: sessionParam.sessionValidationModule,\n          sessionPublicKey: await sessionSigner.getAddress(),\n        });\n      } else {\n        throw new Error(\"sessionID or sessionValidationModule should be provided.\");\n      }\n\n      sessionDataTuple.push(sessionSignerData.validUntil);\n      sessionDataTuple.push(sessionSignerData.validAfter);\n      sessionDataTuple.push(sessionSignerData.sessionValidationModule);\n      sessionDataTuple.push(sessionSignerData.sessionKeyData);\n\n      const leafDataHex = concat([\n        pad(toHex(sessionSignerData.validUntil), { size: 6 }),\n        pad(toHex(sessionSignerData.validAfter), { size: 6 }),\n        pad(sessionSignerData.sessionValidationModule, { size: 20 }),\n        sessionSignerData.sessionKeyData,\n      ]);\n\n      const proof = this.sessionKeyManagerModule.merkleTree.getHexProof(keccak256(leafDataHex));\n\n      sessionDataTuple.push(proof);\n      sessionDataTuple.push(sessionParam.additionalSessionData ?? \"0x\");\n\n      sessionDataTupleArray.push(sessionDataTuple);\n    }\n\n    // Generate the padded signature\n\n    const paddedSignature = defaultAbiCoder.encode(\n      [\"address\", \"tuple(uint48,uint48,address,bytes,bytes32[],bytes)[]\", \"bytes\"],\n      [this.getSessionKeyManagerAddress(), sessionDataTupleArray, signature],\n    );\n\n    return paddedSignature as Hex;\n  }\n\n  /**\n   * Update the session data pending state to active\n   * @param param The search param to find the session data\n   * @param status The status to be updated\n   * @returns\n   */\n  async updateSessionStatus(param: SessionSearchParam, status: SessionStatus): Promise<void> {\n    this.sessionKeyManagerModule.sessionStorageClient.updateSessionStatus(param, status);\n  }\n\n  /**\n   * @remarks This method is used to clear all the pending sessions\n   * @returns\n   */\n  async clearPendingSessions(): Promise<void> {\n    this.sessionKeyManagerModule.sessionStorageClient.clearPendingSessions();\n  }\n\n  /**\n   * @returns SessionKeyManagerModule address\n   */\n  getAddress(): Hex {\n    return this.moduleAddress;\n  }\n\n  /**\n   * @returns SessionKeyManagerModule address\n   */\n  getSessionKeyManagerAddress(): Hex {\n    return this.sessionManagerModuleAddress;\n  }\n\n  /**\n   * @remarks This is the version of the module contract\n   */\n  async getSigner(): Promise<SmartAccountSigner> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * @remarks This is the dummy signature for the module, used in buildUserOp for bundler estimation\n   * @returns Dummy signature\n   */\n  async getDummySignature(params?: ModuleInfo): Promise<Hex> {\n    const sessionParams = params?.batchSessionParams;\n    if (!sessionParams || sessionParams.length === 0) {\n      throw new Error(\"Session parameters are not provided\");\n    }\n\n    const sessionDataTupleArray = [];\n\n    // if needed we could do mock signature over userOpHashAndModuleAddress\n\n    // signer must be the same for all the sessions\n    const { signer: sessionSigner } = await convertSigner(sessionParams[0].sessionSigner);\n\n    for (const sessionParam of sessionParams) {\n      if (!sessionParam.sessionSigner) {\n        throw new Error(\"Session signer is not provided.\");\n      }\n\n      const sessionDataTuple = [];\n\n      let sessionSignerData;\n\n      if (sessionParam.sessionID) {\n        sessionSignerData = await this.sessionKeyManagerModule.sessionStorageClient.getSessionData({\n          sessionID: sessionParam.sessionID,\n        });\n      } else if (sessionParam.sessionValidationModule) {\n        sessionSignerData = await this.sessionKeyManagerModule.sessionStorageClient.getSessionData({\n          sessionValidationModule: sessionParam.sessionValidationModule,\n          sessionPublicKey: await sessionSigner.getAddress(),\n        });\n      } else {\n        throw new Error(\"sessionID or sessionValidationModule should be provided.\");\n      }\n\n      sessionDataTuple.push(BigInt(sessionSignerData.validUntil));\n      sessionDataTuple.push(BigInt(sessionSignerData.validAfter));\n      sessionDataTuple.push(sessionSignerData.sessionValidationModule);\n      sessionDataTuple.push(sessionSignerData.sessionKeyData);\n\n      const leafDataHex = concat([\n        pad(toHex(sessionSignerData.validUntil), { size: 6 }),\n        pad(toHex(sessionSignerData.validAfter), { size: 6 }),\n        pad(sessionSignerData.sessionValidationModule, { size: 20 }),\n        sessionSignerData.sessionKeyData,\n      ]);\n\n      const proof = this.sessionKeyManagerModule.merkleTree.getHexProof(keccak256(leafDataHex));\n\n      sessionDataTuple.push(proof);\n      sessionDataTuple.push(sessionParam.additionalSessionData ?? \"0x\");\n\n      sessionDataTupleArray.push(sessionDataTuple);\n    }\n\n    // Generate the padded signature\n    const paddedSignature = defaultAbiCoder.encode(\n      [\"address\", \"tuple(uint48,uint48,address,bytes,bytes32[],bytes)[]\", \"bytes\"],\n      [this.getSessionKeyManagerAddress(), sessionDataTupleArray, this.mockEcdsaSessionKeySig],\n    );\n\n    const dummySig = encodeAbiParameters(parseAbiParameters(\"bytes, address\"), [paddedSignature as Hex, this.getAddress()]);\n    return dummySig;\n  }\n\n  /**\n   * @remarks Other modules may need additional attributes to build init data\n   */\n  async getInitData(): Promise<Hex> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * @remarks This Module dont have knowledge of signer. So, this method is not implemented\n   */\n  async signMessage(_message: Uint8Array | string): Promise<string> {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n"]}