"use strict";import{concat as u,encodeAbiParameters as S,encodeFunctionData as m,keccak256 as d,pad as i,parseAbi as A,parseAbiParameters as g,toBytes as M,toHex as r}from"viem";import{MerkleTree as b}from"merkletreejs";import{StorageType as p}from"./utils/Types.js";import{SESSION_MANAGER_MODULE_ADDRESSES_BY_VERSION as E,DEFAULT_SESSION_KEY_MANAGER_MODULE as k}from"./utils/Constants.js";import{generateRandomHex as I}from"./utils/Uid.js";import{BaseValidationModule as x}from"./BaseValidationModule.js";import{SessionLocalStorage as h}from"./session-storage/SessionLocalStorage.js";import{convertSigner as v}from"@biconomy/common";export class SessionKeyManagerModule extends x{constructor(e){super(e),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:"V1_0_0"}),Object.defineProperty(this,"moduleAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"merkleTree",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"sessionStorageClient",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"mockEcdsaSessionKeySig",{enumerable:!0,configurable:!0,writable:!0,value:"0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b"}),Object.defineProperty(this,"createSessionData",{enumerable:!0,configurable:!0,writable:!0,value:async s=>{const n=A(["function setMerkleRoot(bytes32 _merkleRoot)"]),o=[],t=[];for(const a of s){const y=u([i(r(a.validUntil),{size:6}),i(r(a.validAfter),{size:6}),i(a.sessionValidationModule,{size:20}),a.sessionKeyData]),f=a.preferredSessionId??I();o.push(d(y)),t.push(f);const D={...a,sessionID:f,status:"PENDING"};await this.sessionStorageClient.addSessionData(D)}this.merkleTree.addLeaves(o);const l=this.merkleTree.getLeaves(),c=new b(l,d,{sortPairs:!0,hashLeaves:!1});this.merkleTree=c;const w=m({abi:n,functionName:"setMerkleRoot",args:[this.merkleTree.getHexRoot()]});return await this.sessionStorageClient.setMerkleRoot(this.merkleTree.getHexRoot()),{data:w,sessionIDInfo:t}}})}static async create(e){const s=new SessionKeyManagerModule(e);if(e.moduleAddress)s.moduleAddress=e.moduleAddress;else if(e.version){const t=E[e.version];if(!t)throw new Error(`Invalid version ${e.version}`);s.moduleAddress=t,s.version=e.version}else s.moduleAddress=k;if(e.sessionStorageClient)s.sessionStorageClient=e.sessionStorageClient;else switch(e.storageType){case p.LOCAL_STORAGE:s.sessionStorageClient=new h(e.smartAccountAddress);break;default:s.sessionStorageClient=new h(e.smartAccountAddress)}const o=(await s.sessionStorageClient.getAllSessionData()).map(t=>{const l=u([i(r(t.validUntil),{size:6}),i(r(t.validAfter),{size:6}),i(t.sessionValidationModule,{size:20}),t.sessionKeyData]);return d(l)});return s.merkleTree=new b(o,d,{sortPairs:!0,hashLeaves:!1}),s}async signUserOpHash(e,s){if(!(s&&s.sessionSigner))throw new Error("Session signer is not provided.");const{signer:n}=await v(s.sessionSigner),o=await n.signMessage(M(e)),t=await this.getLeafInfo(s),l=u([i(r(t.validUntil),{size:6}),i(r(t.validAfter),{size:6}),i(t.sessionValidationModule,{size:20}),t.sessionKeyData]);let c=S(g("uint48, uint48, address, bytes, bytes32[], bytes"),[t.validUntil,t.validAfter,t.sessionValidationModule,t.sessionKeyData,this.merkleTree.getHexProof(d(l)),o]);return s?.additionalSessionData&&(c+=s.additionalSessionData),c}async getLeafInfo(e){if(!(e&&e.sessionSigner))throw new Error("Session signer is not provided.");const{signer:s}=await v(e.sessionSigner);let n;if(e?.sessionID)n=await this.sessionStorageClient.getSessionData({sessionID:e.sessionID});else if(e?.sessionValidationModule)n=await this.sessionStorageClient.getSessionData({sessionValidationModule:e.sessionValidationModule,sessionPublicKey:await s.getAddress()});else throw new Error("sessionID or sessionValidationModule should be provided.");return n}async updateSessionStatus(e,s){this.sessionStorageClient.updateSessionStatus(e,s)}async clearPendingSessions(){this.sessionStorageClient.clearPendingSessions()}getAddress(){return this.moduleAddress}async getSigner(){throw new Error("Method not implemented.")}async getDummySignature(e){if(!e)throw new Error("Session signer is not provided.");const s=await this.getLeafInfo(e),n=u([i(r(s.validUntil),{size:6}),i(r(s.validAfter),{size:6}),i(s.sessionValidationModule,{size:20}),s.sessionKeyData]);let o=S(g("uint48, uint48, address, bytes, bytes32[], bytes"),[s.validUntil,s.validAfter,s.sessionValidationModule,s.sessionKeyData,this.merkleTree.getHexProof(d(n)),this.mockEcdsaSessionKeySig]);return e?.additionalSessionData&&(o+=e.additionalSessionData),S(g(["bytes, address"]),[o,this.getAddress()])}async getInitData(){throw new Error("Method not implemented.")}async signMessage(e){throw new Error("Method not implemented.")}}
