"use strict";import{getChain as f}from"@alchemy/aa-core";import{createPublicClient as x,http as w}from"viem";import{transformUserOP as v,getTimestampInSeconds as l}from"./utils/HelperFunction.js";import{UserOpReceiptIntervals as R,UserOpWaitForTxHashIntervals as P,UserOpWaitForTxHashMaxDurationIntervals as B,UserOpReceiptMaxDurationIntervals as H,DEFAULT_ENTRYPOINT_ADDRESS as T}from"./utils/Constants.js";import{extractChainIdFromBundlerUrl as D}from"./utils/Utils.js";import{sendRequest as u,HttpMethod as c}from"@biconomy/common";export class Bundler{constructor(e){Object.defineProperty(this,"bundlerConfig",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"UserOpReceiptIntervals",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"UserOpWaitForTxHashIntervals",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"UserOpReceiptMaxDurationIntervals",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"UserOpWaitForTxHashMaxDurationIntervals",{enumerable:!0,configurable:!0,writable:!0,value:void 0});const t=e?.chainId||D(e.bundlerUrl);this.bundlerConfig={...e,chainId:t},this.UserOpReceiptIntervals={...R,...e.userOpReceiptIntervals},this.UserOpWaitForTxHashIntervals={...P,...e.userOpWaitForTxHashIntervals},this.UserOpReceiptMaxDurationIntervals={...H,...e.userOpReceiptMaxDurationIntervals},this.UserOpWaitForTxHashMaxDurationIntervals={...B,...e.userOpWaitForTxHashMaxDurationIntervals},this.bundlerConfig.entryPointAddress=e.entryPointAddress||T}getBundlerUrl(){return`${this.bundlerConfig.bundlerUrl}`}async estimateUserOpGas(e){e=v(e);const t=this.getBundlerUrl(),s=(await u({url:t,method:c.Post,body:{method:"eth_estimateUserOperationGas",params:[e,this.bundlerConfig.entryPointAddress],id:l(),jsonrpc:"2.0"}},"Bundler")).result;for(const o in s)if(!(o==="maxFeePerGas"||o==="maxPriorityFeePerGas")&&(s[o]===void 0||s[o]===null))throw new Error(`Got undefined ${o} from bundler`);return s}async sendUserOp(e,t){const r=this.bundlerConfig.chainId;e=v(e);const s={simulation_type:t||"validation"},o=[e,this.bundlerConfig.entryPointAddress,s],y=this.getBundlerUrl(),p=await u({url:y,method:c.Post,body:{method:"eth_sendUserOperation",params:o,id:l(),jsonrpc:"2.0"}},"Bundler");return{userOpHash:p.result,wait:d=>{const O=x({chain:f(r),transport:w()}),U=this.UserOpReceiptMaxDurationIntervals[r]||3e4;let h=0;return new Promise((m,i)=>{const n=this.UserOpReceiptIntervals[r]||5e3,b=setInterval(async()=>{try{const a=await this.getUserOpReceipt(p.result);if(a&&a.receipt&&a.receipt.blockNumber)if(d){const I=await O.getBlockNumber(),g=Number(I)-a.receipt.blockNumber;if(d>=g){clearInterval(b),m(a);return}}else{clearInterval(b),m(a);return}}catch(a){clearInterval(b),i(a);return}h+=n,h>=U&&(clearInterval(b),i(new Error(`Exceeded maximum duration (${U/1e3} sec) waiting to get receipt for userOpHash ${p.result}. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`)))},n)})},waitForTxHash:()=>{const d=this.UserOpWaitForTxHashMaxDurationIntervals[r]||2e4;let O=0;return new Promise((U,h)=>{const m=this.UserOpWaitForTxHashIntervals[r]||500,i=setInterval(async()=>{try{const n=await this.getUserOpStatus(p.result);if(n&&n.state&&n.transactionHash){clearInterval(i),U(n);return}}catch(n){clearInterval(i),h(n);return}O+=m,O>=d&&(clearInterval(i),h(new Error(`Exceeded maximum duration (${d/1e3} sec) waiting to get receipt for userOpHash ${p.result}. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`)))},m)})}}}async getUserOpReceipt(e){const t=this.getBundlerUrl();return(await u({url:t,method:c.Post,body:{method:"eth_getUserOperationReceipt",params:[e],id:l(),jsonrpc:"2.0"}},"Bundler")).result}async getUserOpStatus(e){const t=this.getBundlerUrl();return(await u({url:t,method:c.Post,body:{method:"biconomy_getUserOperationStatus",params:[e],id:l(),jsonrpc:"2.0"}},"Bundler")).result}async getUserOpByHash(e){const t=this.getBundlerUrl();return(await u({url:t,method:c.Post,body:{method:"eth_getUserOperationByHash",params:[e],id:l(),jsonrpc:"2.0"}},"Bundler")).result}async getGasFeeValues(){const e=this.getBundlerUrl();return(await u({url:e,method:c.Post,body:{method:"biconomy_getGasFeeValues",params:[],id:l(),jsonrpc:"2.0"}},"Bundler")).result}static async create(e){return new Bundler(e)}}
