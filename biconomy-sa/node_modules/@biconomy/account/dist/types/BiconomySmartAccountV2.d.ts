import { Hex, PublicClient, GetContractReturnType } from "viem";
import { BaseSmartContractAccount, type UserOperationStruct, BatchUserOperationCallData } from "@alchemy/aa-core";
import { BaseValidationModule, ModuleInfo, SendUserOpParams } from "@biconomy/modules";
import { IPaymaster, IBundler, UserOpResponse } from "./index.js";
import { BiconomyTokenPaymasterRequest, BiconomySmartAccountV2Config, CounterFactualAddressParam, BuildUserOpOptions, Transaction, QueryParamsForAddressResolver, BiconomySmartAccountV2ConfigConstructorProps, PaymasterUserOperationDto, SimulationType } from "./utils/Types.js";
import { BiconomyAccountAbi } from "./abi/SmartAccount.js";
import { FeeQuotesOrDataResponse } from "@biconomy/paymaster";
type UserOperationKey = keyof UserOperationStruct;
export declare class BiconomySmartAccountV2 extends BaseSmartContractAccount {
    readonly biconomySmartAccountConfig: BiconomySmartAccountV2ConfigConstructorProps;
    private SENTINEL_MODULE;
    private index;
    private chainId;
    private provider;
    paymaster?: IPaymaster;
    bundler?: IBundler;
    private accountContract?;
    private defaultFallbackHandlerAddress;
    private implementationAddress;
    private scanForUpgradedAccountsFromV1;
    private maxIndexForScan;
    defaultValidationModule: BaseValidationModule;
    activeValidationModule: BaseValidationModule;
    private constructor();
    /**
     * Creates a new instance of BiconomySmartAccountV2
     *
     * This method will create a BiconomySmartAccountV2 instance but will not deploy the Smart Account
     * Deployment of the Smart Account will be donewith the first user operation.
     *
     * - Docs: https://docs.biconomy.io/Account/integration#integration-1
     *
     * @param biconomySmartAccountConfig - Configuration for initializing the BiconomySmartAccountV2 instance.
     * @returns A promise that resolves to a new instance of BiconomySmartAccountV2.
     * @throws An error if something is wrong with the smart account instance creation.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient, BiconomySmartAccountV2 } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonMumbai } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonMumbai,
     *   transport: http(),
     * });
     *
     * const bundlerUrl = "" // Retrieve bundler url from dasboard
     *
     * const smartAccountFromStaticCreate = await BiconomySmartAccountV2.create({ signer, bundlerUrl });
     *
     * // Is the same as...
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl });
     *
     */
    static create(biconomySmartAccountConfig: BiconomySmartAccountV2Config): Promise<BiconomySmartAccountV2>;
    getAddress(params?: CounterFactualAddressParam): Promise<Hex>;
    getAccountAddress(params?: CounterFactualAddressParam): Promise<`0x${string}`>;
    /**
     * Return the account's address. This value is valid even before deploying the contract.
     */
    getCounterFactualAddress(params?: CounterFactualAddressParam): Promise<Hex>;
    private getCounterFactualAddressV2;
    _getAccountContract(): Promise<GetContractReturnType<typeof BiconomyAccountAbi, PublicClient>>;
    isActiveValidationModuleDefined(): boolean;
    isDefaultValidationModuleDefined(): boolean;
    setActiveValidationModule(validationModule: BaseValidationModule): BiconomySmartAccountV2;
    setDefaultValidationModule(validationModule: BaseValidationModule): BiconomySmartAccountV2;
    getV1AccountsUpgradedToV2(params: QueryParamsForAddressResolver): Promise<Hex>;
    /**
     * Return the value to put into the "initCode" field, if the account is not yet deployed.
     * This value holds the "factory" address, followed by this account's information
     */
    getAccountInitCode(): Promise<Hex>;
    /**
     *
     * @param to { target } address of transaction
     * @param value  represents amount of native tokens
     * @param data represent data associated with transaction
     * @returns encoded data for execute function
     */
    encodeExecute(to: Hex, value: bigint, data: Hex): Promise<Hex>;
    /**
     *
     * @param to { target } array of addresses in transaction
     * @param value  represents array of amount of native tokens associated with each transaction
     * @param data represent array of data associated with each transaction
     * @returns encoded data for executeBatch function
     */
    encodeExecuteBatch(to: Array<Hex>, value: Array<bigint>, data: Array<Hex>): Promise<Hex>;
    encodeBatchExecute(txs: BatchUserOperationCallData): Promise<Hex>;
    getDummySignatures(params?: ModuleInfo): Promise<Hex>;
    getDummySignature(): Hex;
    getDummyPaymasterData(): string;
    validateUserOp(userOp: Partial<UserOperationStruct>, requiredFields: UserOperationKey[]): boolean;
    signUserOp(userOp: Partial<UserOperationStruct>, params?: SendUserOpParams): Promise<UserOperationStruct>;
    getSignatureWithModuleAddress(moduleSignature: Hex, moduleAddress?: Hex): Hex;
    getPaymasterUserOp(userOp: Partial<UserOperationStruct>, paymasterServiceData: PaymasterUserOperationDto): Promise<Partial<UserOperationStruct>>;
    private getPaymasterAndData;
    private getPaymasterFeeQuotesOrData;
    /**
     *
     * @description This function will retrieve fees from the paymaster in erc20 mode
     *
     * @param manyOrOneTransactions Array of {@link Transaction} to be batched and sent. Can also be a single {@link Transaction}.
     * @param buildUseropDto {@link BuildUserOpOptions}.
     * @returns Promise<FeeQuotesOrDataResponse>
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonMumbai } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonMumbai,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dasboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const transaction = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const feeQuotesResponse: FeeQuotesOrDataResponse = await smartAccount.getTokenFees(transaction, { paymasterServiceData: { mode: PaymasterMode.ERC20 } });
     *
     * const userSeletedFeeQuote = feeQuotesResponse.feeQuotes?.[0];
     *
     * const { wait } = await smartAccount.sendTransaction(transaction, {
     *    paymasterServiceData: {
     *      mode: PaymasterMode.ERC20,
     *      feeQuote: userSeletedFeeQuote,
     *      spender: feeQuotesResponse.tokenPaymasterAddress,
     *    },
     * });
     *
     * const { receipt } = await wait();
     *
     */
    getTokenFees(manyOrOneTransactions: Transaction | Transaction[], buildUseropDto: BuildUserOpOptions): Promise<FeeQuotesOrDataResponse>;
    /**
     *
     * @param userOp
     * @param params
     * @description This function will take a user op as an input, sign it with the owner key, and send it to the bundler.
     * @returns Promise<UserOpResponse>
     * Sends a user operation
     *
     * - Docs: https://docs.biconomy.io/Account/transactions/userpaid#send-useroperation
     *
     * @param userOp Partial<{@link UserOperationStruct}> the userOp params to be sent.
     * @param params {@link SendUserOpParams}.
     * @returns Promise<{@link UserOpResponse}> that you can use to track user operation.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonMumbai } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonMumbai,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dasboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const transaction = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const userOp = await smartAccount.buildUserOp([transaction]);
     *
     * const { wait } = await smartAccount.sendUserOp(userOp);
     * const { receipt } = await wait();
     *
     */
    sendUserOp(userOp: Partial<UserOperationStruct>, params?: SendUserOpParams): Promise<UserOpResponse>;
    /**
     *
     * @param userOp - The signed user operation to send
     * @param simulationType - The type of simulation to perform ("validation" | "validation_and_execution")
     * @description This function call will take 'signedUserOp' as input and send it to the bundler
     * @returns
     */
    sendSignedUserOp(userOp: UserOperationStruct, simulationType?: SimulationType): Promise<UserOpResponse>;
    getUserOpHash(userOp: Partial<UserOperationStruct>): Promise<Hex>;
    estimateUserOpGas(userOp: Partial<UserOperationStruct>): Promise<Partial<UserOperationStruct>>;
    getNonce(nonceKey?: number): Promise<bigint>;
    private getBuildUserOpNonce;
    /**
     * Sends a transaction (builds and sends a user op in sequence)
     *
     * - Docs: https://docs.biconomy.io/Account/transactions/userpaid#send-transaction
     *
     * @param manyOrOneTransactions Array of {@link Transaction} to be batched and sent. Can also be a single {@link Transaction}.
     * @param buildUseropDto {@link BuildUserOpOptions}.
     * @returns Promise<{@link UserOpResponse}> that you can use to track user operation.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonMumbai } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonMumbai,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dasboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const transaction = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const { waitForTxHash } = await smartAccount.sendTransaction(transaction);
     * const { transactionHash, userOperationReceipt } = await wait();
     *
     */
    sendTransaction(manyOrOneTransactions: Transaction | Transaction[], buildUseropDto?: BuildUserOpOptions): Promise<UserOpResponse>;
    /**
     * Builds a user operation
     *
     * - Docs: https://docs.biconomy.io/Account/transactions/userpaid#build-useroperation
     *
     * @param transactions Array of {@link Transaction} to be sent.
     * @param buildUseropDto {@link BuildUserOpOptions}.
     * @returns Promise<Partial{@link UserOperationStruct}>> the built user operation to be sent.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonMumbai } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonMumbai,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dasboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const transaction = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const userOp = await smartAccount.buildUserOp([{ to: "0x...", data: encodedCall }]);
     *
     */
    buildUserOp(transactions: Transaction[], buildUseropDto?: BuildUserOpOptions): Promise<Partial<UserOperationStruct>>;
    private validateUserOpAndPaymasterRequest;
    /**
     *
     * @param userOp partial user operation without signature and paymasterAndData
     * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.
     *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.
     * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster
     * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)
     * @returns updated userOp with new callData, callGasLimit
     */
    buildTokenPaymasterUserOp(userOp: Partial<UserOperationStruct>, tokenPaymasterRequest: BiconomyTokenPaymasterRequest): Promise<Partial<UserOperationStruct>>;
    signUserOpHash(userOpHash: string, params?: ModuleInfo): Promise<Hex>;
    signMessage(message: string | Uint8Array): Promise<Hex>;
    enableModule(moduleAddress: Hex): Promise<UserOpResponse>;
    getEnableModuleData(moduleAddress: Hex): Promise<Transaction>;
    getSetupAndEnableModuleData(moduleAddress: Hex, moduleSetupData: Hex): Promise<Transaction>;
    disableModule(prevModule: Hex, moduleAddress: Hex): Promise<UserOpResponse>;
    getDisableModuleData(prevModule: Hex, moduleAddress: Hex): Promise<Transaction>;
    isModuleEnabled(moduleAddress: Hex): Promise<boolean>;
    getAllModules(pageSize?: number): Promise<Array<string>>;
}
export {};
//# sourceMappingURL=BiconomySmartAccountV2.d.ts.map