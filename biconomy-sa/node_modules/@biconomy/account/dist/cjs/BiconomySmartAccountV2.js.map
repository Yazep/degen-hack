{"version":3,"file":"BiconomySmartAccountV2.js","sourceRoot":"","sources":["../../src/BiconomySmartAccountV2.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Hex,\n  keccak256,\n  encodePacked,\n  getCreate2Address,\n  encodeAbiParameters,\n  parseAbiParameters,\n  toHex,\n  toBytes,\n  encodeFunctionData,\n  PublicClient,\n  createPublicClient,\n  http,\n  concatHex,\n  GetContractReturnType,\n  getContract,\n  decodeFunctionData,\n} from \"viem\";\nimport {\n  BaseSmartContractAccount,\n  getChain,\n  type BigNumberish,\n  type UserOperationStruct,\n  BatchUserOperationCallData,\n  SmartAccountSigner,\n} from \"@alchemy/aa-core\";\nimport { isNullOrUndefined, packUserOp } from \"./utils/Utils.js\";\nimport { BaseValidationModule, ModuleInfo, SendUserOpParams, createECDSAOwnershipValidationModule } from \"@biconomy/modules\";\nimport {\n  IHybridPaymaster,\n  IPaymaster,\n  Paymaster,\n  PaymasterMode,\n  SponsorUserOperationDto,\n  Bundler,\n  IBundler,\n  UserOpResponse,\n  extractChainIdFromBundlerUrl,\n  convertSigner,\n} from \"./index.js\";\nimport {\n  BiconomyTokenPaymasterRequest,\n  BiconomySmartAccountV2Config,\n  CounterFactualAddressParam,\n  BuildUserOpOptions,\n  NonceOptions,\n  Transaction,\n  QueryParamsForAddressResolver,\n  BiconomySmartAccountV2ConfigConstructorProps,\n  PaymasterUserOperationDto,\n  SimulationType,\n} from \"./utils/Types.js\";\nimport {\n  ADDRESS_RESOLVER_ADDRESS,\n  BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION,\n  DEFAULT_BICONOMY_FACTORY_ADDRESS,\n  DEFAULT_FALLBACK_HANDLER_ADDRESS,\n  PROXY_CREATION_CODE,\n  ADDRESS_ZERO,\n  DEFAULT_ENTRYPOINT_ADDRESS,\n  ERROR_MESSAGES,\n} from \"./utils/Constants.js\";\nimport { BiconomyFactoryAbi } from \"./abi/Factory.js\";\nimport { BiconomyAccountAbi } from \"./abi/SmartAccount.js\";\nimport { AccountResolverAbi } from \"./abi/AccountResolver.js\";\nimport { Logger } from \"@biconomy/common\";\nimport { FeeQuotesOrDataDto, FeeQuotesOrDataResponse } from \"@biconomy/paymaster\";\n\ntype UserOperationKey = keyof UserOperationStruct;\n\nexport class BiconomySmartAccountV2 extends BaseSmartContractAccount {\n  private SENTINEL_MODULE = \"0x0000000000000000000000000000000000000001\";\n\n  private index: number;\n\n  private chainId: number;\n\n  private provider: PublicClient;\n\n  paymaster?: IPaymaster;\n\n  bundler?: IBundler;\n\n  private accountContract?: GetContractReturnType<typeof BiconomyAccountAbi, PublicClient>;\n\n  private defaultFallbackHandlerAddress: Hex;\n\n  private implementationAddress: Hex;\n\n  private scanForUpgradedAccountsFromV1!: boolean;\n\n  private maxIndexForScan!: number;\n\n  // Validation module responsible for account deployment initCode. This acts as a default authorization module.\n  defaultValidationModule!: BaseValidationModule;\n\n  // Deployed Smart Account can have more than one module enabled. When sending a transaction activeValidationModule is used to prepare and validate userOp signature.\n  activeValidationModule!: BaseValidationModule;\n\n  private constructor(readonly biconomySmartAccountConfig: BiconomySmartAccountV2ConfigConstructorProps) {\n    super({\n      ...biconomySmartAccountConfig,\n      chain: getChain(biconomySmartAccountConfig.chainId),\n      rpcClient: biconomySmartAccountConfig.rpcUrl || getChain(biconomySmartAccountConfig.chainId).rpcUrls.default.http[0],\n      entryPointAddress: (biconomySmartAccountConfig.entryPointAddress as Hex) ?? DEFAULT_ENTRYPOINT_ADDRESS,\n      accountAddress: (biconomySmartAccountConfig.accountAddress as Hex) ?? undefined,\n      factoryAddress: biconomySmartAccountConfig.factoryAddress ?? DEFAULT_BICONOMY_FACTORY_ADDRESS,\n    });\n\n    this.defaultValidationModule = biconomySmartAccountConfig.defaultValidationModule;\n    this.activeValidationModule = biconomySmartAccountConfig.activeValidationModule;\n\n    this.index = biconomySmartAccountConfig.index ?? 0;\n    this.chainId = biconomySmartAccountConfig.chainId;\n    this.bundler = biconomySmartAccountConfig.bundler;\n    this.implementationAddress = biconomySmartAccountConfig.implementationAddress ?? (BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION.V2_0_0 as Hex);\n\n    if (biconomySmartAccountConfig.biconomyPaymasterApiKey) {\n      this.paymaster = new Paymaster({\n        paymasterUrl: `https://paymaster.biconomy.io/api/v1/${biconomySmartAccountConfig.chainId}/${biconomySmartAccountConfig.biconomyPaymasterApiKey}`,\n      });\n    } else {\n      this.paymaster = biconomySmartAccountConfig.paymaster;\n    }\n\n    this.bundler = biconomySmartAccountConfig.bundler;\n\n    const defaultFallbackHandlerAddress =\n      this.factoryAddress === DEFAULT_BICONOMY_FACTORY_ADDRESS ? DEFAULT_FALLBACK_HANDLER_ADDRESS : biconomySmartAccountConfig.defaultFallbackHandler;\n    if (!defaultFallbackHandlerAddress) {\n      throw new Error(\"Default Fallback Handler address is not provided\");\n    }\n    this.defaultFallbackHandlerAddress = defaultFallbackHandlerAddress;\n\n    // Added bang operator to avoid null check as the constructor have these params as optional\n    this.defaultValidationModule = biconomySmartAccountConfig.defaultValidationModule!;\n    this.activeValidationModule = biconomySmartAccountConfig.activeValidationModule!;\n\n    this.provider = createPublicClient({\n      chain: getChain(biconomySmartAccountConfig.chainId),\n      transport: http(biconomySmartAccountConfig.rpcUrl || getChain(biconomySmartAccountConfig.chainId).rpcUrls.default.http[0]),\n    });\n\n    this.scanForUpgradedAccountsFromV1 = biconomySmartAccountConfig.scanForUpgradedAccountsFromV1 ?? false;\n    this.maxIndexForScan = biconomySmartAccountConfig.maxIndexForScan ?? 10;\n  }\n\n  /**\n   * Creates a new instance of BiconomySmartAccountV2\n   *\n   * This method will create a BiconomySmartAccountV2 instance but will not deploy the Smart Account\n   * Deployment of the Smart Account will be donewith the first user operation.\n   *\n   * - Docs: https://docs.biconomy.io/Account/integration#integration-1\n   *\n   * @param biconomySmartAccountConfig - Configuration for initializing the BiconomySmartAccountV2 instance.\n   * @returns A promise that resolves to a new instance of BiconomySmartAccountV2.\n   * @throws An error if something is wrong with the smart account instance creation.\n   *\n   * @example\n   * import { createClient } from \"viem\"\n   * import { createSmartAccountClient, BiconomySmartAccountV2 } from \"@biconomy/account\"\n   * import { createWalletClient, http } from \"viem\";\n   * import { polygonMumbai } from \"viem/chains\";\n   *\n   * const signer = createWalletClient({\n   *   account,\n   *   chain: polygonMumbai,\n   *   transport: http(),\n   * });\n   *\n   * const bundlerUrl = \"\" // Retrieve bundler url from dasboard\n   *\n   * const smartAccountFromStaticCreate = await BiconomySmartAccountV2.create({ signer, bundlerUrl });\n   *\n   * // Is the same as...\n   *\n   * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl });\n   *\n   */\n  public static async create(biconomySmartAccountConfig: BiconomySmartAccountV2Config): Promise<BiconomySmartAccountV2> {\n    let chainId = biconomySmartAccountConfig.chainId;\n    let resolvedSmartAccountSigner!: SmartAccountSigner;\n    let rpcUrl = biconomySmartAccountConfig.rpcUrl;\n\n    // Signer needs to be initialised here before defaultValidationModule is set\n    if (biconomySmartAccountConfig.signer) {\n      const signerResult = await convertSigner(biconomySmartAccountConfig.signer, !!chainId);\n      if (!chainId && !!signerResult.chainId) {\n        chainId = signerResult.chainId;\n      }\n      if (!rpcUrl && !!signerResult.rpcUrl) {\n        rpcUrl = signerResult.rpcUrl;\n      }\n      resolvedSmartAccountSigner = signerResult.signer;\n    }\n    if (!chainId) {\n      // Get it from bundler\n      if (biconomySmartAccountConfig.bundlerUrl) {\n        chainId = extractChainIdFromBundlerUrl(biconomySmartAccountConfig.bundlerUrl);\n      } else if (biconomySmartAccountConfig.bundler) {\n        const bundlerUrlFromBundler = biconomySmartAccountConfig.bundler.getBundlerUrl();\n        chainId = extractChainIdFromBundlerUrl(bundlerUrlFromBundler);\n      }\n    }\n    if (!chainId) {\n      throw new Error(\"chainId required\");\n    }\n    const bundler: IBundler = biconomySmartAccountConfig.bundler ?? new Bundler({ bundlerUrl: biconomySmartAccountConfig.bundlerUrl!, chainId });\n    let defaultValidationModule = biconomySmartAccountConfig.defaultValidationModule;\n\n    // Note: If no module is provided, we will use ECDSA_OWNERSHIP as default\n    if (!defaultValidationModule) {\n      const newModule = await createECDSAOwnershipValidationModule({ signer: resolvedSmartAccountSigner! });\n      defaultValidationModule = newModule;\n    }\n    const activeValidationModule = biconomySmartAccountConfig?.activeValidationModule ?? defaultValidationModule;\n    if (!resolvedSmartAccountSigner) {\n      resolvedSmartAccountSigner = await activeValidationModule.getSigner();\n    }\n    if (!resolvedSmartAccountSigner) {\n      throw new Error(\"signer required\");\n    }\n    const config: BiconomySmartAccountV2ConfigConstructorProps = {\n      ...biconomySmartAccountConfig,\n      defaultValidationModule,\n      activeValidationModule,\n      chainId,\n      bundler,\n      signer: resolvedSmartAccountSigner,\n      rpcUrl,\n    };\n\n    return new BiconomySmartAccountV2(config);\n  }\n\n  // Calls the getCounterFactualAddress\n  async getAddress(params?: CounterFactualAddressParam): Promise<Hex> {\n    if (this.accountAddress == null) {\n      // means it needs deployment\n      this.accountAddress = await this.getCounterFactualAddress(params);\n    }\n    return this.accountAddress;\n  }\n\n  // Calls the getCounterFactualAddress\n  async getAccountAddress(params?: CounterFactualAddressParam): Promise<`0x${string}`> {\n    if (this.accountAddress == null || this.accountAddress == undefined) {\n      // means it needs deployment\n      this.accountAddress = await this.getCounterFactualAddress(params);\n    }\n    return this.accountAddress;\n  }\n\n  /**\n   * Return the account's address. This value is valid even before deploying the contract.\n   */\n  async getCounterFactualAddress(params?: CounterFactualAddressParam): Promise<Hex> {\n    const validationModule = params?.validationModule ?? this.defaultValidationModule;\n    const index = params?.index ?? this.index;\n\n    const maxIndexForScan = params?.maxIndexForScan ?? this.maxIndexForScan;\n    // Review: default behavior\n    const scanForUpgradedAccountsFromV1 = params?.scanForUpgradedAccountsFromV1 ?? this.scanForUpgradedAccountsFromV1;\n\n    // if it's intended to detect V1 upgraded accounts\n    if (scanForUpgradedAccountsFromV1) {\n      const eoaSigner = await validationModule.getSigner();\n      const eoaAddress = (await eoaSigner.getAddress()) as Hex;\n      const moduleAddress = validationModule.getAddress() as Hex;\n      const moduleSetupData = (await validationModule.getInitData()) as Hex;\n      const queryParams = {\n        eoaAddress,\n        index,\n        moduleAddress,\n        moduleSetupData,\n        maxIndexForScan,\n      };\n      const accountAddress = await this.getV1AccountsUpgradedToV2(queryParams);\n      if (accountAddress !== ADDRESS_ZERO) {\n        return accountAddress;\n      }\n    }\n\n    const counterFactualAddressV2 = await this.getCounterFactualAddressV2({ validationModule, index });\n    return counterFactualAddressV2;\n  }\n\n  private async getCounterFactualAddressV2(params?: CounterFactualAddressParam): Promise<Hex> {\n    const validationModule = params?.validationModule ?? this.defaultValidationModule;\n    const index = params?.index ?? this.index;\n\n    try {\n      const initCalldata = encodeFunctionData({\n        abi: BiconomyAccountAbi,\n        functionName: \"init\",\n        args: [this.defaultFallbackHandlerAddress, validationModule.getAddress() as Hex, (await validationModule.getInitData()) as Hex],\n      });\n\n      const proxyCreationCodeHash = keccak256(encodePacked([\"bytes\", \"uint256\"], [PROXY_CREATION_CODE, BigInt(this.implementationAddress)]));\n\n      const salt = keccak256(encodePacked([\"bytes32\", \"uint256\"], [keccak256(initCalldata), BigInt(index)]));\n\n      const counterFactualAddress = getCreate2Address({\n        from: this.factoryAddress,\n        salt: salt,\n        bytecodeHash: proxyCreationCodeHash,\n      });\n\n      return counterFactualAddress;\n    } catch (e) {\n      throw new Error(`Failed to get counterfactual address, ${e}`);\n    }\n  }\n\n  async _getAccountContract(): Promise<GetContractReturnType<typeof BiconomyAccountAbi, PublicClient>> {\n    if (this.accountContract == null) {\n      this.accountContract = getContract({\n        address: await this.getAddress(),\n        abi: BiconomyAccountAbi,\n        client: this.provider as PublicClient,\n      });\n    }\n    return this.accountContract;\n  }\n\n  isActiveValidationModuleDefined(): boolean {\n    if (!this.activeValidationModule) throw new Error(\"Must provide an instance of active validation module.\");\n    return true;\n  }\n\n  isDefaultValidationModuleDefined(): boolean {\n    if (!this.defaultValidationModule) throw new Error(\"Must provide an instance of default validation module.\");\n    return true;\n  }\n\n  setActiveValidationModule(validationModule: BaseValidationModule): BiconomySmartAccountV2 {\n    if (validationModule instanceof BaseValidationModule) {\n      this.activeValidationModule = validationModule;\n    }\n    return this;\n  }\n\n  setDefaultValidationModule(validationModule: BaseValidationModule): BiconomySmartAccountV2 {\n    if (validationModule instanceof BaseValidationModule) {\n      this.defaultValidationModule = validationModule;\n    }\n    return this;\n  }\n\n  async getV1AccountsUpgradedToV2(params: QueryParamsForAddressResolver): Promise<Hex> {\n    const maxIndexForScan = params.maxIndexForScan ?? this.maxIndexForScan;\n\n    const addressResolver = getContract({\n      address: ADDRESS_RESOLVER_ADDRESS,\n      abi: AccountResolverAbi,\n      client: {\n        public: this.provider as PublicClient,\n      },\n    });\n    // Note: depending on moduleAddress and moduleSetupData passed call this. otherwise could call resolveAddresses()\n\n    if (params.moduleAddress && params.moduleSetupData) {\n      const result = await addressResolver.read.resolveAddressesFlexibleForV2([\n        params.eoaAddress,\n        maxIndexForScan,\n        params.moduleAddress,\n        params.moduleSetupData,\n      ]);\n\n      const desiredV1Account = result.find(\n        (smartAccountInfo: { factoryVersion: string; currentVersion: string; deploymentIndex: { toString: () => any } }) =>\n          smartAccountInfo.factoryVersion === \"v1\" &&\n          smartAccountInfo.currentVersion === \"2.0.0\" &&\n          Number(smartAccountInfo.deploymentIndex.toString()) === params.index,\n      );\n\n      if (desiredV1Account) {\n        const smartAccountAddress = desiredV1Account.accountAddress;\n        return smartAccountAddress;\n      } else {\n        return ADDRESS_ZERO;\n      }\n    } else {\n      return ADDRESS_ZERO;\n    }\n  }\n\n  /**\n   * Return the value to put into the \"initCode\" field, if the account is not yet deployed.\n   * This value holds the \"factory\" address, followed by this account's information\n   */\n  async getAccountInitCode(): Promise<Hex> {\n    this.isDefaultValidationModuleDefined();\n\n    return concatHex([\n      this.factoryAddress as Hex,\n      encodeFunctionData({\n        abi: BiconomyFactoryAbi,\n        functionName: \"deployCounterFactualAccount\",\n        args: [this.defaultValidationModule.getAddress() as Hex, (await this.defaultValidationModule.getInitData()) as Hex, BigInt(this.index)],\n      }),\n    ]);\n  }\n\n  /**\n   *\n   * @param to { target } address of transaction\n   * @param value  represents amount of native tokens\n   * @param data represent data associated with transaction\n   * @returns encoded data for execute function\n   */\n  async encodeExecute(to: Hex, value: bigint, data: Hex): Promise<Hex> {\n    // return accountContract.interface.encodeFunctionData(\"execute_ncC\", [to, value, data]) as Hex;\n    return encodeFunctionData({\n      abi: BiconomyAccountAbi,\n      functionName: \"execute_ncC\",\n      args: [to, value, data],\n    });\n  }\n\n  /**\n   *\n   * @param to { target } array of addresses in transaction\n   * @param value  represents array of amount of native tokens associated with each transaction\n   * @param data represent array of data associated with each transaction\n   * @returns encoded data for executeBatch function\n   */\n  async encodeExecuteBatch(to: Array<Hex>, value: Array<bigint>, data: Array<Hex>): Promise<Hex> {\n    return encodeFunctionData({\n      abi: BiconomyAccountAbi,\n      functionName: \"executeBatch_y6U\",\n      args: [to, value, data],\n    });\n  }\n\n  override async encodeBatchExecute(txs: BatchUserOperationCallData): Promise<Hex> {\n    const [targets, datas, value] = txs.reduce(\n      (accum, curr) => {\n        accum[0].push(curr.target);\n        accum[1].push(curr.data);\n        accum[2].push(curr.value || BigInt(0));\n\n        return accum;\n      },\n      [[], [], []] as [Hex[], Hex[], bigint[]],\n    );\n\n    return this.encodeExecuteBatch(targets, value, datas);\n  }\n\n  // dummy signature depends on the validation module supplied.\n  async getDummySignatures(params?: ModuleInfo): Promise<Hex> {\n    this.isActiveValidationModuleDefined();\n    return (await this.activeValidationModule.getDummySignature(params)) as Hex;\n  }\n\n  // TODO: review this\n  getDummySignature(): Hex {\n    throw new Error(\"Method not implemented! Call getDummySignatures instead.\");\n  }\n\n  // Might use provided paymaster instance to get dummy data (from pm service)\n  getDummyPaymasterData(): string {\n    return \"0x\";\n  }\n\n  validateUserOp(userOp: Partial<UserOperationStruct>, requiredFields: UserOperationKey[]): boolean {\n    for (const field of requiredFields) {\n      if (!userOp[field]) {\n        throw new Error(`${String(field)} is missing in the UserOp`);\n      }\n    }\n    return true;\n  }\n\n  async signUserOp(userOp: Partial<UserOperationStruct>, params?: SendUserOpParams): Promise<UserOperationStruct> {\n    this.isActiveValidationModuleDefined();\n    const requiredFields: UserOperationKey[] = [\n      \"sender\",\n      \"nonce\",\n      \"initCode\",\n      \"callData\",\n      \"callGasLimit\",\n      \"verificationGasLimit\",\n      \"preVerificationGas\",\n      \"maxFeePerGas\",\n      \"maxPriorityFeePerGas\",\n      \"paymasterAndData\",\n    ];\n    this.validateUserOp(userOp, requiredFields);\n    const userOpHash = await this.getUserOpHash(userOp);\n\n    const moduleSig = (await this.activeValidationModule.signUserOpHash(userOpHash, params)) as Hex;\n\n    const signatureWithModuleAddress = this.getSignatureWithModuleAddress(moduleSig, this.activeValidationModule.getAddress() as Hex);\n\n    userOp.signature = signatureWithModuleAddress;\n    return userOp as UserOperationStruct;\n  }\n\n  getSignatureWithModuleAddress(moduleSignature: Hex, moduleAddress?: Hex): Hex {\n    const moduleAddressToUse = moduleAddress ?? (this.activeValidationModule.getAddress() as Hex);\n    return encodeAbiParameters(parseAbiParameters(\"bytes, address\"), [moduleSignature, moduleAddressToUse]);\n  }\n\n  public async getPaymasterUserOp(\n    userOp: Partial<UserOperationStruct>,\n    paymasterServiceData: PaymasterUserOperationDto,\n  ): Promise<Partial<UserOperationStruct>> {\n    if (paymasterServiceData.mode === PaymasterMode.SPONSORED) {\n      return this.getPaymasterAndData(userOp, paymasterServiceData);\n    } else if (paymasterServiceData.mode === PaymasterMode.ERC20) {\n      if (paymasterServiceData?.feeQuote) {\n        const { feeQuote, spender, maxApproval = false } = paymasterServiceData;\n        Logger.log(\"there is a feeQuote: \", feeQuote);\n        if (!spender) throw new Error(ERROR_MESSAGES.SPENDER_REQUIRED);\n        if (!feeQuote) throw new Error(ERROR_MESSAGES.FAILED_FEE_QUOTE_FETCH);\n        const partialUserOp = await this.buildTokenPaymasterUserOp(userOp, {\n          ...paymasterServiceData,\n          spender,\n          maxApproval,\n          feeQuote,\n        });\n        return this.getPaymasterAndData(partialUserOp, {\n          ...paymasterServiceData,\n          feeTokenAddress: feeQuote.tokenAddress,\n          calculateGasLimits: true, // Always recommended and especially when using token paymaster\n        });\n      } else if (paymasterServiceData?.preferredToken) {\n        const { preferredToken } = paymasterServiceData;\n        Logger.log(\"there is a preferred token: \", preferredToken);\n        const feeQuotesResponse = await this.getPaymasterFeeQuotesOrData(userOp, paymasterServiceData);\n        const spender = feeQuotesResponse.tokenPaymasterAddress;\n        const feeQuote = feeQuotesResponse.feeQuotes?.[0];\n        if (!spender) throw new Error(ERROR_MESSAGES.SPENDER_REQUIRED);\n        if (!feeQuote) throw new Error(ERROR_MESSAGES.FAILED_FEE_QUOTE_FETCH);\n        return this.getPaymasterUserOp(userOp, { ...paymasterServiceData, feeQuote, spender }); // Recursively call getPaymasterUserOp with the feeQuote\n      } else {\n        Logger.log(\"ERC20 mode without feeQuote or preferredToken provided. Passing through unchanged.\");\n        return userOp;\n      }\n    }\n    throw new Error(\"Invalid paymaster mode\");\n  }\n\n  private async getPaymasterAndData(\n    userOp: Partial<UserOperationStruct>,\n    paymasterServiceData: PaymasterUserOperationDto,\n  ): Promise<Partial<UserOperationStruct>> {\n    const paymaster = this.paymaster as IHybridPaymaster<PaymasterUserOperationDto>;\n    const paymasterData = await paymaster.getPaymasterAndData(userOp, paymasterServiceData);\n    return { ...userOp, ...paymasterData };\n  }\n\n  private async getPaymasterFeeQuotesOrData(\n    userOp: Partial<UserOperationStruct>,\n    feeQuotesOrData: FeeQuotesOrDataDto,\n  ): Promise<FeeQuotesOrDataResponse> {\n    const paymaster = this.paymaster as IHybridPaymaster<PaymasterUserOperationDto>;\n    const tokenList = feeQuotesOrData?.preferredToken\n      ? [feeQuotesOrData?.preferredToken]\n      : feeQuotesOrData?.tokenList?.length\n        ? feeQuotesOrData?.tokenList\n        : [];\n    return paymaster.getPaymasterFeeQuotesOrData(userOp, { ...feeQuotesOrData, tokenList });\n  }\n\n  /**\n   *\n   * @description This function will retrieve fees from the paymaster in erc20 mode\n   *\n   * @param manyOrOneTransactions Array of {@link Transaction} to be batched and sent. Can also be a single {@link Transaction}.\n   * @param buildUseropDto {@link BuildUserOpOptions}.\n   * @returns Promise<FeeQuotesOrDataResponse>\n   *\n   * @example\n   * import { createClient } from \"viem\"\n   * import { createSmartAccountClient } from \"@biconomy/account\"\n   * import { createWalletClient, http } from \"viem\";\n   * import { polygonMumbai } from \"viem/chains\";\n   *\n   * const signer = createWalletClient({\n   *   account,\n   *   chain: polygonMumbai,\n   *   transport: http(),\n   * });\n   *\n   * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dasboard\n   * const encodedCall = encodeFunctionData({\n   *   abi: parseAbi([\"function safeMint(address to) public\"]),\n   *   functionName: \"safeMint\",\n   *   args: [\"0x...\"],\n   * });\n   *\n   * const transaction = {\n   *   to: nftAddress,\n   *   data: encodedCall\n   * }\n   *\n   * const feeQuotesResponse: FeeQuotesOrDataResponse = await smartAccount.getTokenFees(transaction, { paymasterServiceData: { mode: PaymasterMode.ERC20 } });\n   *\n   * const userSeletedFeeQuote = feeQuotesResponse.feeQuotes?.[0];\n   *\n   * const { wait } = await smartAccount.sendTransaction(transaction, {\n   *    paymasterServiceData: {\n   *      mode: PaymasterMode.ERC20,\n   *      feeQuote: userSeletedFeeQuote,\n   *      spender: feeQuotesResponse.tokenPaymasterAddress,\n   *    },\n   * });\n   *\n   * const { receipt } = await wait();\n   *\n   */\n  public async getTokenFees(\n    manyOrOneTransactions: Transaction | Transaction[],\n    buildUseropDto: BuildUserOpOptions,\n  ): Promise<FeeQuotesOrDataResponse> {\n    const txs = Array.isArray(manyOrOneTransactions) ? manyOrOneTransactions : [manyOrOneTransactions];\n    const userOp = await this.buildUserOp(txs, buildUseropDto);\n    if (!buildUseropDto.paymasterServiceData) throw new Error(\"paymasterServiceData was not provided\");\n    return this.getPaymasterFeeQuotesOrData(userOp, buildUseropDto.paymasterServiceData);\n  }\n\n  /**\n   *\n   * @param userOp\n   * @param params\n   * @description This function will take a user op as an input, sign it with the owner key, and send it to the bundler.\n   * @returns Promise<UserOpResponse>\n   * Sends a user operation\n   *\n   * - Docs: https://docs.biconomy.io/Account/transactions/userpaid#send-useroperation\n   *\n   * @param userOp Partial<{@link UserOperationStruct}> the userOp params to be sent.\n   * @param params {@link SendUserOpParams}.\n   * @returns Promise<{@link UserOpResponse}> that you can use to track user operation.\n   *\n   * @example\n   * import { createClient } from \"viem\"\n   * import { createSmartAccountClient } from \"@biconomy/account\"\n   * import { createWalletClient, http } from \"viem\";\n   * import { polygonMumbai } from \"viem/chains\";\n   *\n   * const signer = createWalletClient({\n   *   account,\n   *   chain: polygonMumbai,\n   *   transport: http(),\n   * });\n   *\n   * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dasboard\n   * const encodedCall = encodeFunctionData({\n   *   abi: parseAbi([\"function safeMint(address to) public\"]),\n   *   functionName: \"safeMint\",\n   *   args: [\"0x...\"],\n   * });\n   *\n   * const transaction = {\n   *   to: nftAddress,\n   *   data: encodedCall\n   * }\n   *\n   * const userOp = await smartAccount.buildUserOp([transaction]);\n   *\n   * const { wait } = await smartAccount.sendUserOp(userOp);\n   * const { receipt } = await wait();\n   *\n   */\n  async sendUserOp(userOp: Partial<UserOperationStruct>, params?: SendUserOpParams): Promise<UserOpResponse> {\n    delete userOp.signature;\n    const userOperation = await this.signUserOp(userOp, params);\n    const bundlerResponse = await this.sendSignedUserOp(userOperation, params?.simulationType);\n    return bundlerResponse;\n  }\n\n  /**\n   *\n   * @param userOp - The signed user operation to send\n   * @param simulationType - The type of simulation to perform (\"validation\" | \"validation_and_execution\")\n   * @description This function call will take 'signedUserOp' as input and send it to the bundler\n   * @returns\n   */\n  async sendSignedUserOp(userOp: UserOperationStruct, simulationType?: SimulationType): Promise<UserOpResponse> {\n    const requiredFields: UserOperationKey[] = [\n      \"sender\",\n      \"nonce\",\n      \"initCode\",\n      \"callData\",\n      \"callGasLimit\",\n      \"verificationGasLimit\",\n      \"preVerificationGas\",\n      \"maxFeePerGas\",\n      \"maxPriorityFeePerGas\",\n      \"paymasterAndData\",\n      \"signature\",\n    ];\n    this.validateUserOp(userOp, requiredFields);\n    if (!this.bundler) throw new Error(\"Bundler is not provided\");\n    Logger.warn(\"userOp being sent to the bundler\", userOp);\n    const bundlerResponse = await this.bundler.sendUserOp(userOp, simulationType);\n    return bundlerResponse;\n  }\n\n  async getUserOpHash(userOp: Partial<UserOperationStruct>): Promise<Hex> {\n    const userOpHash = keccak256(packUserOp(userOp, true) as Hex);\n    const enc = encodeAbiParameters(parseAbiParameters(\"bytes32, address, uint256\"), [userOpHash, this.entryPoint.address, BigInt(this.chainId)]);\n    return keccak256(enc);\n  }\n\n  async estimateUserOpGas(userOp: Partial<UserOperationStruct>): Promise<Partial<UserOperationStruct>> {\n    if (!this.bundler) throw new Error(\"Bundler is not provided\");\n    const requiredFields: UserOperationKey[] = [\"sender\", \"nonce\", \"initCode\", \"callData\"];\n    this.validateUserOp(userOp, requiredFields);\n\n    const finalUserOp = userOp;\n\n    // Making call to bundler to get gas estimations for userOp\n    const { callGasLimit, verificationGasLimit, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas } =\n      await this.bundler.estimateUserOpGas(userOp);\n    // if neither user sent gas fee nor the bundler, estimate gas from provider\n    if (!userOp.maxFeePerGas && !userOp.maxPriorityFeePerGas && (!maxFeePerGas || !maxPriorityFeePerGas)) {\n      const feeData = await this.provider.estimateFeesPerGas();\n      if (feeData.maxFeePerGas?.toString()) {\n        finalUserOp.maxFeePerGas = (\"0x\" + feeData.maxFeePerGas.toString(16)) as Hex;\n      } else if (feeData.gasPrice?.toString()) {\n        finalUserOp.maxFeePerGas = (\"0x\" + feeData.gasPrice.toString(16)) as Hex;\n      } else {\n        finalUserOp.maxFeePerGas = (\"0x\" + (await this.provider.getGasPrice()).toString(16)) as Hex;\n      }\n\n      if (feeData.maxPriorityFeePerGas?.toString()) {\n        finalUserOp.maxPriorityFeePerGas = (\"0x\" + feeData.maxPriorityFeePerGas?.toString()) as Hex;\n      } else if (feeData.gasPrice?.toString()) {\n        finalUserOp.maxPriorityFeePerGas = toHex(Number(feeData.gasPrice?.toString()));\n      } else {\n        finalUserOp.maxPriorityFeePerGas = (\"0x\" + (await this.provider.getGasPrice()).toString(16)) as Hex;\n      }\n    } else {\n      finalUserOp.maxFeePerGas = toHex(Number(maxFeePerGas)) ?? userOp.maxFeePerGas;\n      finalUserOp.maxPriorityFeePerGas = toHex(Number(maxPriorityFeePerGas)) ?? userOp.maxPriorityFeePerGas;\n    }\n    finalUserOp.verificationGasLimit = toHex(Number(verificationGasLimit)) ?? userOp.verificationGasLimit;\n    finalUserOp.callGasLimit = toHex(Number(callGasLimit)) ?? userOp.callGasLimit;\n    finalUserOp.preVerificationGas = toHex(Number(preVerificationGas)) ?? userOp.preVerificationGas;\n    if (!finalUserOp.paymasterAndData) {\n      finalUserOp.paymasterAndData = \"0x\";\n    }\n\n    return finalUserOp;\n  }\n\n  // Could call it nonce space\n  async getNonce(nonceKey?: number): Promise<bigint> {\n    const nonceSpace = nonceKey ?? 0;\n    try {\n      const address = await this.getAddress();\n      return await this.entryPoint.read.getNonce([address, BigInt(nonceSpace)]);\n    } catch (e) {\n      return BigInt(0);\n    }\n  }\n\n  private async getBuildUserOpNonce(nonceOptions: NonceOptions | undefined): Promise<BigNumberish> {\n    let nonce = BigInt(0);\n    try {\n      if (nonceOptions?.nonceOverride) {\n        nonce = BigInt(nonceOptions?.nonceOverride);\n      } else {\n        const _nonceSpace = nonceOptions?.nonceKey ?? 0;\n        nonce = await this.getNonce(_nonceSpace);\n      }\n    } catch (error) {\n      // Not throwing this error as nonce would be 0 if this.getNonce() throw exception, which is expected flow for undeployed account\n      Logger.warn(\"Error while getting nonce for the account. This is expected for undeployed accounts set nonce to 0\");\n    }\n    return nonce;\n  }\n\n  /**\n   * Sends a transaction (builds and sends a user op in sequence)\n   *\n   * - Docs: https://docs.biconomy.io/Account/transactions/userpaid#send-transaction\n   *\n   * @param manyOrOneTransactions Array of {@link Transaction} to be batched and sent. Can also be a single {@link Transaction}.\n   * @param buildUseropDto {@link BuildUserOpOptions}.\n   * @returns Promise<{@link UserOpResponse}> that you can use to track user operation.\n   *\n   * @example\n   * import { createClient } from \"viem\"\n   * import { createSmartAccountClient } from \"@biconomy/account\"\n   * import { createWalletClient, http } from \"viem\";\n   * import { polygonMumbai } from \"viem/chains\";\n   *\n   * const signer = createWalletClient({\n   *   account,\n   *   chain: polygonMumbai,\n   *   transport: http(),\n   * });\n   *\n   * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dasboard\n   * const encodedCall = encodeFunctionData({\n   *   abi: parseAbi([\"function safeMint(address to) public\"]),\n   *   functionName: \"safeMint\",\n   *   args: [\"0x...\"],\n   * });\n   *\n   * const transaction = {\n   *   to: nftAddress,\n   *   data: encodedCall\n   * }\n   *\n   * const { waitForTxHash } = await smartAccount.sendTransaction(transaction);\n   * const { transactionHash, userOperationReceipt } = await wait();\n   *\n   */\n  async sendTransaction(manyOrOneTransactions: Transaction | Transaction[], buildUseropDto?: BuildUserOpOptions): Promise<UserOpResponse> {\n    const userOp = await this.buildUserOp(Array.isArray(manyOrOneTransactions) ? manyOrOneTransactions : [manyOrOneTransactions], buildUseropDto);\n    return this.sendUserOp(userOp, { simulationType: buildUseropDto?.simulationType, ...buildUseropDto?.params });\n  }\n\n  /**\n   * Builds a user operation\n   *\n   * - Docs: https://docs.biconomy.io/Account/transactions/userpaid#build-useroperation\n   *\n   * @param transactions Array of {@link Transaction} to be sent.\n   * @param buildUseropDto {@link BuildUserOpOptions}.\n   * @returns Promise<Partial{@link UserOperationStruct}>> the built user operation to be sent.\n   *\n   * @example\n   * import { createClient } from \"viem\"\n   * import { createSmartAccountClient } from \"@biconomy/account\"\n   * import { createWalletClient, http } from \"viem\";\n   * import { polygonMumbai } from \"viem/chains\";\n   *\n   * const signer = createWalletClient({\n   *   account,\n   *   chain: polygonMumbai,\n   *   transport: http(),\n   * });\n   *\n   * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dasboard\n   * const encodedCall = encodeFunctionData({\n   *   abi: parseAbi([\"function safeMint(address to) public\"]),\n   *   functionName: \"safeMint\",\n   *   args: [\"0x...\"],\n   * });\n   *\n   * const transaction = {\n   *   to: nftAddress,\n   *   data: encodedCall\n   * }\n   *\n   * const userOp = await smartAccount.buildUserOp([{ to: \"0x...\", data: encodedCall }]);\n   *\n   */\n  async buildUserOp(transactions: Transaction[], buildUseropDto?: BuildUserOpOptions): Promise<Partial<UserOperationStruct>> {\n    const to = transactions.map((element: Transaction) => element.to as Hex);\n    const data = transactions.map((element: Transaction) => (element.data as Hex) ?? \"0x\");\n    const value = transactions.map((element: Transaction) => (element.value as bigint) ?? BigInt(0));\n\n    const initCodeFetchPromise = this.getInitCode();\n    const dummySignatureFetchPromise = this.getDummySignatures(buildUseropDto?.params);\n\n    const [nonceFromFetch, initCode, signature] = await Promise.all([\n      this.getBuildUserOpNonce(buildUseropDto?.nonceOptions),\n      initCodeFetchPromise,\n      dummySignatureFetchPromise,\n    ]);\n\n    if (transactions.length === 0) {\n      throw new Error(\"Transactions array cannot be empty\");\n    }\n    let callData: Hex = \"0x\";\n    if (transactions.length > 1 || buildUseropDto?.forceEncodeForBatch) {\n      callData = await this.encodeExecuteBatch(to, value, data);\n    } else {\n      // transactions.length must be 1\n      callData = await this.encodeExecute(to[0], value[0], data[0]);\n    }\n\n    let userOp: Partial<UserOperationStruct> = {\n      sender: (await this.getAccountAddress()) as Hex,\n      nonce: toHex(nonceFromFetch),\n      initCode,\n      callData: callData,\n    };\n\n    // for this Smart Account current validation module dummy signature will be used to estimate gas\n    userOp.signature = signature;\n\n    // Note: Can change the default behaviour of calling estimations using bundler/local\n    userOp = await this.estimateUserOpGas(userOp);\n\n    if (buildUseropDto?.paymasterServiceData) {\n      userOp = await this.getPaymasterUserOp(userOp, buildUseropDto.paymasterServiceData);\n    }\n\n    Logger.log(\"UserOp after estimation \", userOp);\n\n    return userOp;\n  }\n\n  private validateUserOpAndPaymasterRequest(userOp: Partial<UserOperationStruct>, tokenPaymasterRequest: BiconomyTokenPaymasterRequest): void {\n    if (isNullOrUndefined(userOp.callData)) {\n      throw new Error(\"UserOp callData cannot be undefined\");\n    }\n\n    const feeTokenAddress = tokenPaymasterRequest?.feeQuote?.tokenAddress;\n    Logger.warn(\"Requested fee token is \", feeTokenAddress);\n\n    if (!feeTokenAddress || feeTokenAddress === ADDRESS_ZERO) {\n      throw new Error(\"Invalid or missing token address. Token address must be part of the feeQuote in tokenPaymasterRequest\");\n    }\n\n    const spender = tokenPaymasterRequest?.spender;\n    Logger.warn(\"Spender address is \", spender);\n\n    if (!spender || spender === ADDRESS_ZERO) {\n      throw new Error(\"Invalid or missing spender address. Sepnder address must be part of tokenPaymasterRequest\");\n    }\n  }\n\n  /**\n   *\n   * @param userOp partial user operation without signature and paymasterAndData\n   * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.\n   *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.\n   * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster\n   * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)\n   * @returns updated userOp with new callData, callGasLimit\n   */\n  async buildTokenPaymasterUserOp(\n    userOp: Partial<UserOperationStruct>,\n    tokenPaymasterRequest: BiconomyTokenPaymasterRequest,\n  ): Promise<Partial<UserOperationStruct>> {\n    this.validateUserOpAndPaymasterRequest(userOp, tokenPaymasterRequest);\n    try {\n      let batchTo: Array<Hex> = [];\n      let batchValue: Array<bigint> = [];\n      let batchData: Array<Hex> = [];\n\n      let newCallData = userOp.callData;\n      Logger.warn(\"Received information about fee token address and quote \", tokenPaymasterRequest);\n\n      if (this.paymaster && this.paymaster instanceof Paymaster) {\n        // Make a call to paymaster.buildTokenApprovalTransaction() with necessary details\n\n        // Review: might request this form of an array of Transaction\n        const approvalRequest: Transaction = await (this.paymaster as IHybridPaymaster<SponsorUserOperationDto>).buildTokenApprovalTransaction(\n          tokenPaymasterRequest,\n        );\n        Logger.warn(\"ApprovalRequest is for erc20 token \", approvalRequest.to);\n\n        if (approvalRequest.data === \"0x\" || approvalRequest.to === ADDRESS_ZERO) {\n          return userOp;\n        }\n\n        if (isNullOrUndefined(userOp.callData)) {\n          throw new Error(\"UserOp callData cannot be undefined\");\n        }\n\n        const decodedSmartAccountData = decodeFunctionData({\n          abi: BiconomyAccountAbi,\n          data: userOp.callData as Hex,\n        });\n\n        if (!decodedSmartAccountData) {\n          throw new Error(\"Could not parse userOp call data for this smart account\");\n        }\n\n        const smartAccountExecFunctionName = decodedSmartAccountData.functionName;\n\n        Logger.warn(`Originally an ${smartAccountExecFunctionName} method call for Biconomy Account V2`);\n        if (smartAccountExecFunctionName === \"execute\" || smartAccountExecFunctionName === \"execute_ncC\") {\n          const methodArgsSmartWalletExecuteCall = decodedSmartAccountData.args;\n          const toOriginal = methodArgsSmartWalletExecuteCall[0];\n          const valueOriginal = methodArgsSmartWalletExecuteCall[1];\n          const dataOriginal = methodArgsSmartWalletExecuteCall[2];\n\n          batchTo.push(toOriginal);\n          batchValue.push(valueOriginal);\n          batchData.push(dataOriginal);\n        } else if (smartAccountExecFunctionName === \"executeBatch\" || smartAccountExecFunctionName === \"executeBatch_y6U\") {\n          const methodArgsSmartWalletExecuteCall = decodedSmartAccountData.args;\n          batchTo = [...methodArgsSmartWalletExecuteCall[0]];\n          batchValue = [...methodArgsSmartWalletExecuteCall[1]];\n          batchData = [...methodArgsSmartWalletExecuteCall[2]];\n        }\n\n        if (approvalRequest.to && approvalRequest.data && approvalRequest.value) {\n          batchTo = [approvalRequest.to as Hex, ...batchTo];\n          batchValue = [BigInt(Number(approvalRequest.value.toString())), ...batchValue];\n          batchData = [approvalRequest.data as Hex, ...batchData];\n\n          newCallData = await this.encodeExecuteBatch(batchTo, batchValue, batchData);\n        }\n        const finalUserOp: Partial<UserOperationStruct> = {\n          ...userOp,\n          callData: newCallData,\n        };\n\n        // Optionally Requesting to update gas limits again (especially callGasLimit needs to be re-calculated)\n\n        return finalUserOp;\n      }\n    } catch (error) {\n      Logger.log(\"Failed to update userOp. Sending back original op\");\n      Logger.error(\"Failed to update callData with error\", error);\n      return userOp;\n    }\n    return userOp;\n  }\n\n  async signUserOpHash(userOpHash: string, params?: ModuleInfo): Promise<Hex> {\n    this.isActiveValidationModuleDefined();\n    const moduleSig = (await this.activeValidationModule.signUserOpHash(userOpHash, params)) as Hex;\n\n    const signatureWithModuleAddress = encodeAbiParameters(parseAbiParameters(\"bytes, address\"), [\n      moduleSig,\n      this.activeValidationModule.getAddress() as Hex,\n    ]);\n\n    return signatureWithModuleAddress;\n  }\n\n  async signMessage(message: string | Uint8Array): Promise<Hex> {\n    this.isActiveValidationModuleDefined();\n    const dataHash = typeof message === \"string\" ? toBytes(message) : message;\n    let signature = await this.activeValidationModule.signMessage(dataHash);\n\n    const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);\n    if (![27, 28].includes(potentiallyIncorrectV)) {\n      const correctV = potentiallyIncorrectV + 27;\n      signature = signature.slice(0, -2) + correctV.toString(16);\n    }\n    if (signature.slice(0, 2) !== \"0x\") {\n      signature = \"0x\" + signature;\n    }\n    return signature as Hex;\n  }\n\n  async enableModule(moduleAddress: Hex): Promise<UserOpResponse> {\n    const tx: Transaction = await this.getEnableModuleData(moduleAddress);\n    const partialUserOp = await this.buildUserOp([tx]);\n    return this.sendUserOp(partialUserOp);\n  }\n\n  async getEnableModuleData(moduleAddress: Hex): Promise<Transaction> {\n    const callData = encodeFunctionData({\n      abi: BiconomyAccountAbi,\n      functionName: \"enableModule\",\n      args: [moduleAddress],\n    });\n    const tx: Transaction = {\n      to: await this.getAddress(),\n      value: \"0x00\",\n      data: callData,\n    };\n    return tx;\n  }\n\n  async getSetupAndEnableModuleData(moduleAddress: Hex, moduleSetupData: Hex): Promise<Transaction> {\n    const callData = encodeFunctionData({\n      abi: BiconomyAccountAbi,\n      functionName: \"setupAndEnableModule\",\n      args: [moduleAddress, moduleSetupData],\n    });\n    const tx: Transaction = {\n      to: await this.getAddress(),\n      value: \"0x00\",\n      data: callData,\n    };\n    return tx;\n  }\n\n  async disableModule(prevModule: Hex, moduleAddress: Hex): Promise<UserOpResponse> {\n    const tx: Transaction = await this.getDisableModuleData(prevModule, moduleAddress);\n    const partialUserOp = await this.buildUserOp([tx]);\n    return this.sendUserOp(partialUserOp);\n  }\n\n  async getDisableModuleData(prevModule: Hex, moduleAddress: Hex): Promise<Transaction> {\n    const callData = encodeFunctionData({\n      abi: BiconomyAccountAbi,\n      functionName: \"disableModule\",\n      args: [prevModule, moduleAddress],\n    });\n    const tx: Transaction = {\n      to: await this.getAddress(),\n      value: \"0x00\",\n      data: callData,\n    };\n    return tx;\n  }\n\n  async isModuleEnabled(moduleAddress: Hex): Promise<boolean> {\n    const accountContract = await this._getAccountContract();\n    return accountContract.read.isModuleEnabled([moduleAddress]);\n  }\n\n  // Review\n  async getAllModules(pageSize?: number): Promise<Array<string>> {\n    pageSize = pageSize ?? 100;\n    const accountContract = await this._getAccountContract();\n    const result = await accountContract.read.getModulesPaginated([this.SENTINEL_MODULE as Hex, BigInt(pageSize)]);\n    const modules: Array<string> = result[0] as Array<string>;\n    return modules;\n  }\n}\n"]}