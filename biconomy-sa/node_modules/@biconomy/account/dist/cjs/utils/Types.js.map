{"version":3,"file":"Types.js","sourceRoot":"","sources":["../../../src/utils/Types.ts"],"names":[],"mappings":"","sourcesContent":["import { BigNumberish, SmartAccountSigner, UserOperationStruct } from \"@alchemy/aa-core\";\nimport { IBundler } from \"@biconomy/bundler\";\nimport {\n  type FeeQuotesOrDataDto,\n  type IPaymaster,\n  type PaymasterFeeQuote,\n  PaymasterMode,\n  type SmartAccountData,\n  type SponsorUserOperationDto,\n} from \"@biconomy/paymaster\";\nimport { BaseValidationModule, ModuleInfo } from \"@biconomy/modules\";\nimport { Hex, WalletClient } from \"viem\";\nimport { SupportedSigner } from \"@biconomy/common\";\n\nexport type EntryPointAddresses = Record<string, string>;\nexport type BiconomyFactories = Record<string, string>;\nexport type BiconomyImplementations = Record<string, string>;\nexport type EntryPointAddressesByVersion = Record<string, string>;\nexport type BiconomyFactoriesByVersion = Record<string, string>;\nexport type BiconomyImplementationsByVersion = Record<string, string>;\n\nexport type SmartAccountConfig = {\n  /** entryPointAddress: address of the smart account factory */\n  entryPointAddress: string;\n  /** factoryAddress: address of the smart account factory */\n  bundler?: IBundler;\n};\n\nexport interface GasOverheads {\n  /** fixed: fixed gas overhead */\n  fixed: number;\n  /** perUserOp: per user operation gas overhead */\n  perUserOp: number;\n  /** perUserOpWord: per user operation word gas overhead */\n  perUserOpWord: number;\n  /** zeroByte: per byte gas overhead */\n  zeroByte: number;\n  /** nonZeroByte: per non zero byte gas overhead */\n  nonZeroByte: number;\n  /** bundleSize: per signature bundleSize */\n  bundleSize: number;\n  /** sigSize: sigSize gas overhead */\n  sigSize: number;\n}\n\nexport type BaseSmartAccountConfig = {\n  /** index: helps to not conflict with other smart account instances */\n  index?: number;\n  /** provider: WalletClientSigner from viem */\n  provider?: WalletClient;\n  /** entryPointAddress: address of the smart account entry point */\n  entryPointAddress?: string;\n  /** accountAddress: address of the smart account, potentially counterfactual */\n  accountAddress?: string;\n  /** overheads: {@link GasOverheads} */\n  overheads?: Partial<GasOverheads>;\n  /** paymaster: {@link IPaymaster} interface */\n  paymaster?: IPaymaster;\n  /** chainId: chainId of the network */\n  chainId?: number;\n};\n\nexport type BiconomyTokenPaymasterRequest = {\n  /** feeQuote: {@link PaymasterFeeQuote} */\n  feeQuote: PaymasterFeeQuote;\n  /** spender: The address of the spender who is paying for the transaction, this can usually be set to feeQuotesResponse.tokenPaymasterAddress */\n  spender: Hex;\n  /** maxApproval: If set to true, the paymaster will approve the maximum amount of tokens required for the transaction. Not recommended */\n  maxApproval?: boolean;\n};\n\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\nexport type ConditionalBundlerProps = RequireAtLeastOne<\n  {\n    bundler: IBundler;\n    bundlerUrl: string;\n  },\n  \"bundler\" | \"bundlerUrl\"\n>;\nexport type ResolvedBundlerProps = {\n  bundler: IBundler;\n};\nexport type ConditionalValidationProps = RequireAtLeastOne<\n  {\n    defaultValidationModule: BaseValidationModule;\n    signer: SupportedSigner;\n  },\n  \"defaultValidationModule\" | \"signer\"\n>;\n\nexport type ResolvedValidationProps = {\n  /** defaultValidationModule: {@link BaseValidationModule} */\n  defaultValidationModule: BaseValidationModule;\n  /** activeValidationModule: {@link BaseValidationModule}. The active validation module. Will default to the defaultValidationModule */\n  activeValidationModule: BaseValidationModule;\n  /** signer: ethers Wallet, viemWallet or alchemys SmartAccountSigner */\n  signer: SmartAccountSigner;\n  /** chainId: chainId of the network */\n  chainId: number;\n};\n\nexport type BiconomySmartAccountV2ConfigBaseProps = {\n  /** Factory address of biconomy factory contract or some other contract you have deployed on chain */\n  factoryAddress?: Hex;\n  /** Sender address: If you want to override the Signer address with some other address and get counterfactual address can use this to pass the EOA and get SA address */\n  senderAddress?: Hex;\n  /** implementation of smart contract address or some other contract you have deployed and want to override */\n  implementationAddress?: Hex;\n  /** defaultFallbackHandler: override the default fallback contract address */\n  defaultFallbackHandler?: Hex;\n  /** rpcUrl: Explicitly set the rpc else it is pulled out of the signer. */\n  rpcUrl?: string; // as good as Provider\n  /** biconomyPaymasterApiKey: The API key retrieved from the Biconomy dashboard */\n  biconomyPaymasterApiKey?: string;\n  /** activeValidationModule: The active validation module. Will default to the defaultValidationModule */\n  activeValidationModule?: BaseValidationModule;\n  /** scanForUpgradedAccountsFromV1: set to true if you you want the userwho was using biconomy SA v1 to upgrade to biconomy SA v2 */\n  scanForUpgradedAccountsFromV1?: boolean;\n  /** the index of SA the EOA have generated and till which indexes the upgraded SA should scan */\n  maxIndexForScan?: number;\n};\nexport type BiconomySmartAccountV2Config = BiconomySmartAccountV2ConfigBaseProps &\n  BaseSmartAccountConfig &\n  ConditionalBundlerProps &\n  ConditionalValidationProps;\n\nexport type BiconomySmartAccountV2ConfigConstructorProps = BiconomySmartAccountV2ConfigBaseProps &\n  BaseSmartAccountConfig &\n  ResolvedBundlerProps &\n  ResolvedValidationProps;\n\nexport type BuildUserOpOptions = {\n  /** overrides: Explicitly set gas values */\n  // overrides?: Overrides;\n  /** Not currently in use  */\n  // skipBundlerGasEstimation?: boolean;\n  /**  params relevant to the module, mostly relevant to sessions */\n  params?: ModuleInfo;\n  /**  nonceOptions: For overriding the nonce */\n  nonceOptions?: NonceOptions;\n  /**  forceEncodeForBatch: For encoding the user operation for batch */\n  forceEncodeForBatch?: boolean;\n  /**  paymasterServiceData: Options specific to transactions that involve a paymaster */\n  paymasterServiceData?: PaymasterUserOperationDto;\n  /**  simulationType: Determine which parts of the tx a bundler will simulate: \"validation\" | \"validation_and_execution\".  */\n  simulationType?: SimulationType;\n};\n\nexport type NonceOptions = {\n  /** nonceKey: The key to use for nonce */\n  nonceKey?: number;\n  /** nonceOverride: The nonce to use for the transaction */\n  nonceOverride?: number;\n};\n\nexport type SimulationType = \"validation\" | \"validation_and_execution\";\n\nexport type Overrides = {\n  /* Value used by inner account execution */\n  callGasLimit?: Hex;\n  /* Actual gas used by the validation of this UserOperation */\n  verificationGasLimit?: Hex;\n  /* Gas overhead of this UserOperation */\n  preVerificationGas?: Hex;\n  /* Maximum fee per gas (similar to EIP-1559 max_fee_per_gas) */\n  maxFeePerGas?: Hex;\n  /* Maximum priority fee per gas (similar to EIP-1559 max_priority_fee_per_gas) */\n  maxPriorityFeePerGas?: Hex;\n  /* Address of paymaster sponsoring the transaction, followed by extra data to send to the paymaster (\"0x\" for self-sponsored transaction) */\n  paymasterData?: Hex;\n  /* Data passed into the account along with the nonce during the verification step */\n  signature?: Hex;\n};\n\nexport type InitilizationData = {\n  accountIndex?: number;\n  signerAddress?: string;\n};\n\nexport type PaymasterUserOperationDto = SponsorUserOperationDto &\n  FeeQuotesOrDataDto & {\n    /** mode: sponsored or erc20 */\n    mode: PaymasterMode;\n    /** Always recommended, especially when using token paymaster */\n    calculateGasLimits?: boolean;\n    /** Expiry duration in seconds */\n    expiryDuration?: number;\n    /** Webhooks to be fired after user op is sent */\n    webhookData?: Record<string, any>;\n    /** Smart account meta data */\n    smartAccountInfo?: SmartAccountData;\n    /** the fee-paying token address */\n    feeTokenAddress?: string;\n    /** The fee quote */\n    feeQuote?: PaymasterFeeQuote;\n    /** The address of the spender. This is usually set to FeeQuotesOrDataResponse.tokenPaymasterAddress  */\n    spender?: Hex;\n    /** Not recommended */\n    maxApproval?: boolean;\n  };\n\nexport type InitializeV2Data = {\n  accountIndex?: number;\n};\n\nexport type EstimateUserOpGasParams = {\n  userOp: Partial<UserOperationStruct>;\n  // overrides?: Overrides;\n  /** Currrently has no effect */\n  // skipBundlerGasEstimation?: boolean;\n  /**  paymasterServiceData: Options specific to transactions that involve a paymaster */\n  paymasterServiceData?: SponsorUserOperationDto;\n};\n\nexport interface TransactionDetailsForUserOp {\n  /** target: The address of the contract to call */\n  target: string;\n  /** data: The data to send to the contract */\n  data: string;\n  /** value: The value to send to the contract */\n  value?: BigNumberish;\n  /** gasLimit: The gas limit to use for the transaction */\n  gasLimit?: BigNumberish;\n  /** maxFeePerGas: The maximum fee per gas to use for the transaction */\n  maxFeePerGas?: BigNumberish;\n  /** maxPriorityFeePerGas: The maximum priority fee per gas to use for the transaction */\n  maxPriorityFeePerGas?: BigNumberish;\n  /** nonce: The nonce to use for the transaction */\n  nonce?: BigNumberish;\n}\n\nexport type CounterFactualAddressParam = {\n  index?: number;\n  validationModule?: BaseValidationModule;\n  /** scanForUpgradedAccountsFromV1: set to true if you you want the userwho was using biconomy SA v1 to upgrade to biconomy SA v2 */\n  scanForUpgradedAccountsFromV1?: boolean;\n  /** the index of SA the EOA have generated and till which indexes the upgraded SA should scan */\n  maxIndexForScan?: number;\n};\n\nexport type QueryParamsForAddressResolver = {\n  eoaAddress: Hex;\n  index: number;\n  moduleAddress: Hex;\n  moduleSetupData: Hex;\n  maxIndexForScan?: number;\n};\n\nexport type SmartAccountInfo = {\n  /** accountAddress: The address of the smart account */\n  accountAddress: Hex;\n  /** factoryAddress: The address of the smart account factory */\n  factoryAddress: Hex;\n  /** currentImplementation: The address of the current implementation */\n  currentImplementation: string;\n  /** currentVersion: The version of the smart account */\n  currentVersion: string;\n  /** factoryVersion: The version of the factory */\n  factoryVersion: string;\n  /** deploymentIndex: The index of the deployment */\n  deploymentIndex: BigNumberish;\n};\n\nexport type ValueOrData = RequireAtLeastOne<\n  {\n    value: BigNumberish | string;\n    data: string;\n  },\n  \"value\" | \"data\"\n>;\nexport type Transaction = {\n  to: string;\n} & ValueOrData;\n"]}