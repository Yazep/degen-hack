import { BigNumberish, SmartAccountSigner, UserOperationStruct } from "@alchemy/aa-core";
import { IBundler } from "@biconomy/bundler";
import { type FeeQuotesOrDataDto, type IPaymaster, type PaymasterFeeQuote, PaymasterMode, type SmartAccountData, type SponsorUserOperationDto } from "@biconomy/paymaster";
import { BaseValidationModule, ModuleInfo } from "@biconomy/modules";
import { Hex, WalletClient } from "viem";
import { SupportedSigner } from "@biconomy/common";
export type EntryPointAddresses = Record<string, string>;
export type BiconomyFactories = Record<string, string>;
export type BiconomyImplementations = Record<string, string>;
export type EntryPointAddressesByVersion = Record<string, string>;
export type BiconomyFactoriesByVersion = Record<string, string>;
export type BiconomyImplementationsByVersion = Record<string, string>;
export type SmartAccountConfig = {
    entryPointAddress: string;
    bundler?: IBundler;
};
export interface GasOverheads {
    fixed: number;
    perUserOp: number;
    perUserOpWord: number;
    zeroByte: number;
    nonZeroByte: number;
    bundleSize: number;
    sigSize: number;
}
export type BaseSmartAccountConfig = {
    index?: number;
    provider?: WalletClient;
    entryPointAddress?: string;
    accountAddress?: string;
    overheads?: Partial<GasOverheads>;
    paymaster?: IPaymaster;
    chainId?: number;
};
export type BiconomyTokenPaymasterRequest = {
    feeQuote: PaymasterFeeQuote;
    spender: Hex;
    maxApproval?: boolean;
};
export type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
export type ConditionalBundlerProps = RequireAtLeastOne<{
    bundler: IBundler;
    bundlerUrl: string;
}, "bundler" | "bundlerUrl">;
export type ResolvedBundlerProps = {
    bundler: IBundler;
};
export type ConditionalValidationProps = RequireAtLeastOne<{
    defaultValidationModule: BaseValidationModule;
    signer: SupportedSigner;
}, "defaultValidationModule" | "signer">;
export type ResolvedValidationProps = {
    defaultValidationModule: BaseValidationModule;
    activeValidationModule: BaseValidationModule;
    signer: SmartAccountSigner;
    chainId: number;
};
export type BiconomySmartAccountV2ConfigBaseProps = {
    factoryAddress?: Hex;
    senderAddress?: Hex;
    implementationAddress?: Hex;
    defaultFallbackHandler?: Hex;
    rpcUrl?: string;
    biconomyPaymasterApiKey?: string;
    activeValidationModule?: BaseValidationModule;
    scanForUpgradedAccountsFromV1?: boolean;
    maxIndexForScan?: number;
};
export type BiconomySmartAccountV2Config = BiconomySmartAccountV2ConfigBaseProps & BaseSmartAccountConfig & ConditionalBundlerProps & ConditionalValidationProps;
export type BiconomySmartAccountV2ConfigConstructorProps = BiconomySmartAccountV2ConfigBaseProps & BaseSmartAccountConfig & ResolvedBundlerProps & ResolvedValidationProps;
export type BuildUserOpOptions = {
    params?: ModuleInfo;
    nonceOptions?: NonceOptions;
    forceEncodeForBatch?: boolean;
    paymasterServiceData?: PaymasterUserOperationDto;
    simulationType?: SimulationType;
};
export type NonceOptions = {
    nonceKey?: number;
    nonceOverride?: number;
};
export type SimulationType = "validation" | "validation_and_execution";
export type Overrides = {
    callGasLimit?: Hex;
    verificationGasLimit?: Hex;
    preVerificationGas?: Hex;
    maxFeePerGas?: Hex;
    maxPriorityFeePerGas?: Hex;
    paymasterData?: Hex;
    signature?: Hex;
};
export type InitilizationData = {
    accountIndex?: number;
    signerAddress?: string;
};
export type PaymasterUserOperationDto = SponsorUserOperationDto & FeeQuotesOrDataDto & {
    mode: PaymasterMode;
    calculateGasLimits?: boolean;
    expiryDuration?: number;
    webhookData?: Record<string, any>;
    smartAccountInfo?: SmartAccountData;
    feeTokenAddress?: string;
    feeQuote?: PaymasterFeeQuote;
    spender?: Hex;
    maxApproval?: boolean;
};
export type InitializeV2Data = {
    accountIndex?: number;
};
export type EstimateUserOpGasParams = {
    userOp: Partial<UserOperationStruct>;
    paymasterServiceData?: SponsorUserOperationDto;
};
export interface TransactionDetailsForUserOp {
    target: string;
    data: string;
    value?: BigNumberish;
    gasLimit?: BigNumberish;
    maxFeePerGas?: BigNumberish;
    maxPriorityFeePerGas?: BigNumberish;
    nonce?: BigNumberish;
}
export type CounterFactualAddressParam = {
    index?: number;
    validationModule?: BaseValidationModule;
    scanForUpgradedAccountsFromV1?: boolean;
    maxIndexForScan?: number;
};
export type QueryParamsForAddressResolver = {
    eoaAddress: Hex;
    index: number;
    moduleAddress: Hex;
    moduleSetupData: Hex;
    maxIndexForScan?: number;
};
export type SmartAccountInfo = {
    accountAddress: Hex;
    factoryAddress: Hex;
    currentImplementation: string;
    currentVersion: string;
    factoryVersion: string;
    deploymentIndex: BigNumberish;
};
export type ValueOrData = RequireAtLeastOne<{
    value: BigNumberish | string;
    data: string;
}, "value" | "data">;
export type Transaction = {
    to: string;
} & ValueOrData;
