"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BiconomySmartAccountV2 = void 0;
const viem_1 = require("viem");
const aa_core_1 = require("@alchemy/aa-core");
const Utils_js_1 = require("./utils/Utils.js");
const modules_1 = require("@biconomy/modules");
const index_js_1 = require("./index.js");
const Constants_js_1 = require("./utils/Constants.js");
const Factory_js_1 = require("./abi/Factory.js");
const SmartAccount_js_1 = require("./abi/SmartAccount.js");
const AccountResolver_js_1 = require("./abi/AccountResolver.js");
const common_1 = require("@biconomy/common");
class BiconomySmartAccountV2 extends aa_core_1.BaseSmartContractAccount {
    constructor(biconomySmartAccountConfig) {
        super({
            ...biconomySmartAccountConfig,
            chain: (0, aa_core_1.getChain)(biconomySmartAccountConfig.chainId),
            rpcClient: biconomySmartAccountConfig.rpcUrl || (0, aa_core_1.getChain)(biconomySmartAccountConfig.chainId).rpcUrls.default.http[0],
            entryPointAddress: biconomySmartAccountConfig.entryPointAddress ?? Constants_js_1.DEFAULT_ENTRYPOINT_ADDRESS,
            accountAddress: biconomySmartAccountConfig.accountAddress ?? undefined,
            factoryAddress: biconomySmartAccountConfig.factoryAddress ?? Constants_js_1.DEFAULT_BICONOMY_FACTORY_ADDRESS,
        });
        Object.defineProperty(this, "biconomySmartAccountConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: biconomySmartAccountConfig
        });
        Object.defineProperty(this, "SENTINEL_MODULE", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "0x0000000000000000000000000000000000000001"
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "chainId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "paymaster", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "bundler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "accountContract", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "defaultFallbackHandlerAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "implementationAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "scanForUpgradedAccountsFromV1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maxIndexForScan", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "defaultValidationModule", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "activeValidationModule", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.defaultValidationModule = biconomySmartAccountConfig.defaultValidationModule;
        this.activeValidationModule = biconomySmartAccountConfig.activeValidationModule;
        this.index = biconomySmartAccountConfig.index ?? 0;
        this.chainId = biconomySmartAccountConfig.chainId;
        this.bundler = biconomySmartAccountConfig.bundler;
        this.implementationAddress = biconomySmartAccountConfig.implementationAddress ?? Constants_js_1.BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION.V2_0_0;
        if (biconomySmartAccountConfig.biconomyPaymasterApiKey) {
            this.paymaster = new index_js_1.Paymaster({
                paymasterUrl: `https://paymaster.biconomy.io/api/v1/${biconomySmartAccountConfig.chainId}/${biconomySmartAccountConfig.biconomyPaymasterApiKey}`,
            });
        }
        else {
            this.paymaster = biconomySmartAccountConfig.paymaster;
        }
        this.bundler = biconomySmartAccountConfig.bundler;
        const defaultFallbackHandlerAddress = this.factoryAddress === Constants_js_1.DEFAULT_BICONOMY_FACTORY_ADDRESS ? Constants_js_1.DEFAULT_FALLBACK_HANDLER_ADDRESS : biconomySmartAccountConfig.defaultFallbackHandler;
        if (!defaultFallbackHandlerAddress) {
            throw new Error("Default Fallback Handler address is not provided");
        }
        this.defaultFallbackHandlerAddress = defaultFallbackHandlerAddress;
        this.defaultValidationModule = biconomySmartAccountConfig.defaultValidationModule;
        this.activeValidationModule = biconomySmartAccountConfig.activeValidationModule;
        this.provider = (0, viem_1.createPublicClient)({
            chain: (0, aa_core_1.getChain)(biconomySmartAccountConfig.chainId),
            transport: (0, viem_1.http)(biconomySmartAccountConfig.rpcUrl || (0, aa_core_1.getChain)(biconomySmartAccountConfig.chainId).rpcUrls.default.http[0]),
        });
        this.scanForUpgradedAccountsFromV1 = biconomySmartAccountConfig.scanForUpgradedAccountsFromV1 ?? false;
        this.maxIndexForScan = biconomySmartAccountConfig.maxIndexForScan ?? 10;
    }
    static async create(biconomySmartAccountConfig) {
        let chainId = biconomySmartAccountConfig.chainId;
        let resolvedSmartAccountSigner;
        let rpcUrl = biconomySmartAccountConfig.rpcUrl;
        if (biconomySmartAccountConfig.signer) {
            const signerResult = await (0, index_js_1.convertSigner)(biconomySmartAccountConfig.signer, !!chainId);
            if (!chainId && !!signerResult.chainId) {
                chainId = signerResult.chainId;
            }
            if (!rpcUrl && !!signerResult.rpcUrl) {
                rpcUrl = signerResult.rpcUrl;
            }
            resolvedSmartAccountSigner = signerResult.signer;
        }
        if (!chainId) {
            if (biconomySmartAccountConfig.bundlerUrl) {
                chainId = (0, index_js_1.extractChainIdFromBundlerUrl)(biconomySmartAccountConfig.bundlerUrl);
            }
            else if (biconomySmartAccountConfig.bundler) {
                const bundlerUrlFromBundler = biconomySmartAccountConfig.bundler.getBundlerUrl();
                chainId = (0, index_js_1.extractChainIdFromBundlerUrl)(bundlerUrlFromBundler);
            }
        }
        if (!chainId) {
            throw new Error("chainId required");
        }
        const bundler = biconomySmartAccountConfig.bundler ?? new index_js_1.Bundler({ bundlerUrl: biconomySmartAccountConfig.bundlerUrl, chainId });
        let defaultValidationModule = biconomySmartAccountConfig.defaultValidationModule;
        if (!defaultValidationModule) {
            const newModule = await (0, modules_1.createECDSAOwnershipValidationModule)({ signer: resolvedSmartAccountSigner });
            defaultValidationModule = newModule;
        }
        const activeValidationModule = biconomySmartAccountConfig?.activeValidationModule ?? defaultValidationModule;
        if (!resolvedSmartAccountSigner) {
            resolvedSmartAccountSigner = await activeValidationModule.getSigner();
        }
        if (!resolvedSmartAccountSigner) {
            throw new Error("signer required");
        }
        const config = {
            ...biconomySmartAccountConfig,
            defaultValidationModule,
            activeValidationModule,
            chainId,
            bundler,
            signer: resolvedSmartAccountSigner,
            rpcUrl,
        };
        return new BiconomySmartAccountV2(config);
    }
    async getAddress(params) {
        if (this.accountAddress == null) {
            this.accountAddress = await this.getCounterFactualAddress(params);
        }
        return this.accountAddress;
    }
    async getAccountAddress(params) {
        if (this.accountAddress == null || this.accountAddress == undefined) {
            this.accountAddress = await this.getCounterFactualAddress(params);
        }
        return this.accountAddress;
    }
    async getCounterFactualAddress(params) {
        const validationModule = params?.validationModule ?? this.defaultValidationModule;
        const index = params?.index ?? this.index;
        const maxIndexForScan = params?.maxIndexForScan ?? this.maxIndexForScan;
        const scanForUpgradedAccountsFromV1 = params?.scanForUpgradedAccountsFromV1 ?? this.scanForUpgradedAccountsFromV1;
        if (scanForUpgradedAccountsFromV1) {
            const eoaSigner = await validationModule.getSigner();
            const eoaAddress = (await eoaSigner.getAddress());
            const moduleAddress = validationModule.getAddress();
            const moduleSetupData = (await validationModule.getInitData());
            const queryParams = {
                eoaAddress,
                index,
                moduleAddress,
                moduleSetupData,
                maxIndexForScan,
            };
            const accountAddress = await this.getV1AccountsUpgradedToV2(queryParams);
            if (accountAddress !== Constants_js_1.ADDRESS_ZERO) {
                return accountAddress;
            }
        }
        const counterFactualAddressV2 = await this.getCounterFactualAddressV2({ validationModule, index });
        return counterFactualAddressV2;
    }
    async getCounterFactualAddressV2(params) {
        const validationModule = params?.validationModule ?? this.defaultValidationModule;
        const index = params?.index ?? this.index;
        try {
            const initCalldata = (0, viem_1.encodeFunctionData)({
                abi: SmartAccount_js_1.BiconomyAccountAbi,
                functionName: "init",
                args: [this.defaultFallbackHandlerAddress, validationModule.getAddress(), (await validationModule.getInitData())],
            });
            const proxyCreationCodeHash = (0, viem_1.keccak256)((0, viem_1.encodePacked)(["bytes", "uint256"], [Constants_js_1.PROXY_CREATION_CODE, BigInt(this.implementationAddress)]));
            const salt = (0, viem_1.keccak256)((0, viem_1.encodePacked)(["bytes32", "uint256"], [(0, viem_1.keccak256)(initCalldata), BigInt(index)]));
            const counterFactualAddress = (0, viem_1.getCreate2Address)({
                from: this.factoryAddress,
                salt: salt,
                bytecodeHash: proxyCreationCodeHash,
            });
            return counterFactualAddress;
        }
        catch (e) {
            throw new Error(`Failed to get counterfactual address, ${e}`);
        }
    }
    async _getAccountContract() {
        if (this.accountContract == null) {
            this.accountContract = (0, viem_1.getContract)({
                address: await this.getAddress(),
                abi: SmartAccount_js_1.BiconomyAccountAbi,
                client: this.provider,
            });
        }
        return this.accountContract;
    }
    isActiveValidationModuleDefined() {
        if (!this.activeValidationModule)
            throw new Error("Must provide an instance of active validation module.");
        return true;
    }
    isDefaultValidationModuleDefined() {
        if (!this.defaultValidationModule)
            throw new Error("Must provide an instance of default validation module.");
        return true;
    }
    setActiveValidationModule(validationModule) {
        if (validationModule instanceof modules_1.BaseValidationModule) {
            this.activeValidationModule = validationModule;
        }
        return this;
    }
    setDefaultValidationModule(validationModule) {
        if (validationModule instanceof modules_1.BaseValidationModule) {
            this.defaultValidationModule = validationModule;
        }
        return this;
    }
    async getV1AccountsUpgradedToV2(params) {
        const maxIndexForScan = params.maxIndexForScan ?? this.maxIndexForScan;
        const addressResolver = (0, viem_1.getContract)({
            address: Constants_js_1.ADDRESS_RESOLVER_ADDRESS,
            abi: AccountResolver_js_1.AccountResolverAbi,
            client: {
                public: this.provider,
            },
        });
        if (params.moduleAddress && params.moduleSetupData) {
            const result = await addressResolver.read.resolveAddressesFlexibleForV2([
                params.eoaAddress,
                maxIndexForScan,
                params.moduleAddress,
                params.moduleSetupData,
            ]);
            const desiredV1Account = result.find((smartAccountInfo) => smartAccountInfo.factoryVersion === "v1" &&
                smartAccountInfo.currentVersion === "2.0.0" &&
                Number(smartAccountInfo.deploymentIndex.toString()) === params.index);
            if (desiredV1Account) {
                const smartAccountAddress = desiredV1Account.accountAddress;
                return smartAccountAddress;
            }
            else {
                return Constants_js_1.ADDRESS_ZERO;
            }
        }
        else {
            return Constants_js_1.ADDRESS_ZERO;
        }
    }
    async getAccountInitCode() {
        this.isDefaultValidationModuleDefined();
        return (0, viem_1.concatHex)([
            this.factoryAddress,
            (0, viem_1.encodeFunctionData)({
                abi: Factory_js_1.BiconomyFactoryAbi,
                functionName: "deployCounterFactualAccount",
                args: [this.defaultValidationModule.getAddress(), (await this.defaultValidationModule.getInitData()), BigInt(this.index)],
            }),
        ]);
    }
    async encodeExecute(to, value, data) {
        return (0, viem_1.encodeFunctionData)({
            abi: SmartAccount_js_1.BiconomyAccountAbi,
            functionName: "execute_ncC",
            args: [to, value, data],
        });
    }
    async encodeExecuteBatch(to, value, data) {
        return (0, viem_1.encodeFunctionData)({
            abi: SmartAccount_js_1.BiconomyAccountAbi,
            functionName: "executeBatch_y6U",
            args: [to, value, data],
        });
    }
    async encodeBatchExecute(txs) {
        const [targets, datas, value] = txs.reduce((accum, curr) => {
            accum[0].push(curr.target);
            accum[1].push(curr.data);
            accum[2].push(curr.value || BigInt(0));
            return accum;
        }, [[], [], []]);
        return this.encodeExecuteBatch(targets, value, datas);
    }
    async getDummySignatures(params) {
        this.isActiveValidationModuleDefined();
        return (await this.activeValidationModule.getDummySignature(params));
    }
    getDummySignature() {
        throw new Error("Method not implemented! Call getDummySignatures instead.");
    }
    getDummyPaymasterData() {
        return "0x";
    }
    validateUserOp(userOp, requiredFields) {
        for (const field of requiredFields) {
            if (!userOp[field]) {
                throw new Error(`${String(field)} is missing in the UserOp`);
            }
        }
        return true;
    }
    async signUserOp(userOp, params) {
        this.isActiveValidationModuleDefined();
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "paymasterAndData",
        ];
        this.validateUserOp(userOp, requiredFields);
        const userOpHash = await this.getUserOpHash(userOp);
        const moduleSig = (await this.activeValidationModule.signUserOpHash(userOpHash, params));
        const signatureWithModuleAddress = this.getSignatureWithModuleAddress(moduleSig, this.activeValidationModule.getAddress());
        userOp.signature = signatureWithModuleAddress;
        return userOp;
    }
    getSignatureWithModuleAddress(moduleSignature, moduleAddress) {
        const moduleAddressToUse = moduleAddress ?? this.activeValidationModule.getAddress();
        return (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)("bytes, address"), [moduleSignature, moduleAddressToUse]);
    }
    async getPaymasterUserOp(userOp, paymasterServiceData) {
        if (paymasterServiceData.mode === index_js_1.PaymasterMode.SPONSORED) {
            return this.getPaymasterAndData(userOp, paymasterServiceData);
        }
        else if (paymasterServiceData.mode === index_js_1.PaymasterMode.ERC20) {
            if (paymasterServiceData?.feeQuote) {
                const { feeQuote, spender, maxApproval = false } = paymasterServiceData;
                common_1.Logger.log("there is a feeQuote: ", feeQuote);
                if (!spender)
                    throw new Error(Constants_js_1.ERROR_MESSAGES.SPENDER_REQUIRED);
                if (!feeQuote)
                    throw new Error(Constants_js_1.ERROR_MESSAGES.FAILED_FEE_QUOTE_FETCH);
                const partialUserOp = await this.buildTokenPaymasterUserOp(userOp, {
                    ...paymasterServiceData,
                    spender,
                    maxApproval,
                    feeQuote,
                });
                return this.getPaymasterAndData(partialUserOp, {
                    ...paymasterServiceData,
                    feeTokenAddress: feeQuote.tokenAddress,
                    calculateGasLimits: true,
                });
            }
            else if (paymasterServiceData?.preferredToken) {
                const { preferredToken } = paymasterServiceData;
                common_1.Logger.log("there is a preferred token: ", preferredToken);
                const feeQuotesResponse = await this.getPaymasterFeeQuotesOrData(userOp, paymasterServiceData);
                const spender = feeQuotesResponse.tokenPaymasterAddress;
                const feeQuote = feeQuotesResponse.feeQuotes?.[0];
                if (!spender)
                    throw new Error(Constants_js_1.ERROR_MESSAGES.SPENDER_REQUIRED);
                if (!feeQuote)
                    throw new Error(Constants_js_1.ERROR_MESSAGES.FAILED_FEE_QUOTE_FETCH);
                return this.getPaymasterUserOp(userOp, { ...paymasterServiceData, feeQuote, spender });
            }
            else {
                common_1.Logger.log("ERC20 mode without feeQuote or preferredToken provided. Passing through unchanged.");
                return userOp;
            }
        }
        throw new Error("Invalid paymaster mode");
    }
    async getPaymasterAndData(userOp, paymasterServiceData) {
        const paymaster = this.paymaster;
        const paymasterData = await paymaster.getPaymasterAndData(userOp, paymasterServiceData);
        return { ...userOp, ...paymasterData };
    }
    async getPaymasterFeeQuotesOrData(userOp, feeQuotesOrData) {
        const paymaster = this.paymaster;
        const tokenList = feeQuotesOrData?.preferredToken
            ? [feeQuotesOrData?.preferredToken]
            : feeQuotesOrData?.tokenList?.length
                ? feeQuotesOrData?.tokenList
                : [];
        return paymaster.getPaymasterFeeQuotesOrData(userOp, { ...feeQuotesOrData, tokenList });
    }
    async getTokenFees(manyOrOneTransactions, buildUseropDto) {
        const txs = Array.isArray(manyOrOneTransactions) ? manyOrOneTransactions : [manyOrOneTransactions];
        const userOp = await this.buildUserOp(txs, buildUseropDto);
        if (!buildUseropDto.paymasterServiceData)
            throw new Error("paymasterServiceData was not provided");
        return this.getPaymasterFeeQuotesOrData(userOp, buildUseropDto.paymasterServiceData);
    }
    async sendUserOp(userOp, params) {
        delete userOp.signature;
        const userOperation = await this.signUserOp(userOp, params);
        const bundlerResponse = await this.sendSignedUserOp(userOperation, params?.simulationType);
        return bundlerResponse;
    }
    async sendSignedUserOp(userOp, simulationType) {
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "paymasterAndData",
            "signature",
        ];
        this.validateUserOp(userOp, requiredFields);
        if (!this.bundler)
            throw new Error("Bundler is not provided");
        common_1.Logger.warn("userOp being sent to the bundler", userOp);
        const bundlerResponse = await this.bundler.sendUserOp(userOp, simulationType);
        return bundlerResponse;
    }
    async getUserOpHash(userOp) {
        const userOpHash = (0, viem_1.keccak256)((0, Utils_js_1.packUserOp)(userOp, true));
        const enc = (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)("bytes32, address, uint256"), [userOpHash, this.entryPoint.address, BigInt(this.chainId)]);
        return (0, viem_1.keccak256)(enc);
    }
    async estimateUserOpGas(userOp) {
        if (!this.bundler)
            throw new Error("Bundler is not provided");
        const requiredFields = ["sender", "nonce", "initCode", "callData"];
        this.validateUserOp(userOp, requiredFields);
        const finalUserOp = userOp;
        const { callGasLimit, verificationGasLimit, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas } = await this.bundler.estimateUserOpGas(userOp);
        if (!userOp.maxFeePerGas && !userOp.maxPriorityFeePerGas && (!maxFeePerGas || !maxPriorityFeePerGas)) {
            const feeData = await this.provider.estimateFeesPerGas();
            if (feeData.maxFeePerGas?.toString()) {
                finalUserOp.maxFeePerGas = ("0x" + feeData.maxFeePerGas.toString(16));
            }
            else if (feeData.gasPrice?.toString()) {
                finalUserOp.maxFeePerGas = ("0x" + feeData.gasPrice.toString(16));
            }
            else {
                finalUserOp.maxFeePerGas = ("0x" + (await this.provider.getGasPrice()).toString(16));
            }
            if (feeData.maxPriorityFeePerGas?.toString()) {
                finalUserOp.maxPriorityFeePerGas = ("0x" + feeData.maxPriorityFeePerGas?.toString());
            }
            else if (feeData.gasPrice?.toString()) {
                finalUserOp.maxPriorityFeePerGas = (0, viem_1.toHex)(Number(feeData.gasPrice?.toString()));
            }
            else {
                finalUserOp.maxPriorityFeePerGas = ("0x" + (await this.provider.getGasPrice()).toString(16));
            }
        }
        else {
            finalUserOp.maxFeePerGas = (0, viem_1.toHex)(Number(maxFeePerGas)) ?? userOp.maxFeePerGas;
            finalUserOp.maxPriorityFeePerGas = (0, viem_1.toHex)(Number(maxPriorityFeePerGas)) ?? userOp.maxPriorityFeePerGas;
        }
        finalUserOp.verificationGasLimit = (0, viem_1.toHex)(Number(verificationGasLimit)) ?? userOp.verificationGasLimit;
        finalUserOp.callGasLimit = (0, viem_1.toHex)(Number(callGasLimit)) ?? userOp.callGasLimit;
        finalUserOp.preVerificationGas = (0, viem_1.toHex)(Number(preVerificationGas)) ?? userOp.preVerificationGas;
        if (!finalUserOp.paymasterAndData) {
            finalUserOp.paymasterAndData = "0x";
        }
        return finalUserOp;
    }
    async getNonce(nonceKey) {
        const nonceSpace = nonceKey ?? 0;
        try {
            const address = await this.getAddress();
            return await this.entryPoint.read.getNonce([address, BigInt(nonceSpace)]);
        }
        catch (e) {
            return BigInt(0);
        }
    }
    async getBuildUserOpNonce(nonceOptions) {
        let nonce = BigInt(0);
        try {
            if (nonceOptions?.nonceOverride) {
                nonce = BigInt(nonceOptions?.nonceOverride);
            }
            else {
                const _nonceSpace = nonceOptions?.nonceKey ?? 0;
                nonce = await this.getNonce(_nonceSpace);
            }
        }
        catch (error) {
            common_1.Logger.warn("Error while getting nonce for the account. This is expected for undeployed accounts set nonce to 0");
        }
        return nonce;
    }
    async sendTransaction(manyOrOneTransactions, buildUseropDto) {
        const userOp = await this.buildUserOp(Array.isArray(manyOrOneTransactions) ? manyOrOneTransactions : [manyOrOneTransactions], buildUseropDto);
        return this.sendUserOp(userOp, { simulationType: buildUseropDto?.simulationType, ...buildUseropDto?.params });
    }
    async buildUserOp(transactions, buildUseropDto) {
        const to = transactions.map((element) => element.to);
        const data = transactions.map((element) => element.data ?? "0x");
        const value = transactions.map((element) => element.value ?? BigInt(0));
        const initCodeFetchPromise = this.getInitCode();
        const dummySignatureFetchPromise = this.getDummySignatures(buildUseropDto?.params);
        const [nonceFromFetch, initCode, signature] = await Promise.all([
            this.getBuildUserOpNonce(buildUseropDto?.nonceOptions),
            initCodeFetchPromise,
            dummySignatureFetchPromise,
        ]);
        if (transactions.length === 0) {
            throw new Error("Transactions array cannot be empty");
        }
        let callData = "0x";
        if (transactions.length > 1 || buildUseropDto?.forceEncodeForBatch) {
            callData = await this.encodeExecuteBatch(to, value, data);
        }
        else {
            callData = await this.encodeExecute(to[0], value[0], data[0]);
        }
        let userOp = {
            sender: (await this.getAccountAddress()),
            nonce: (0, viem_1.toHex)(nonceFromFetch),
            initCode,
            callData: callData,
        };
        userOp.signature = signature;
        userOp = await this.estimateUserOpGas(userOp);
        if (buildUseropDto?.paymasterServiceData) {
            userOp = await this.getPaymasterUserOp(userOp, buildUseropDto.paymasterServiceData);
        }
        common_1.Logger.log("UserOp after estimation ", userOp);
        return userOp;
    }
    validateUserOpAndPaymasterRequest(userOp, tokenPaymasterRequest) {
        if ((0, Utils_js_1.isNullOrUndefined)(userOp.callData)) {
            throw new Error("UserOp callData cannot be undefined");
        }
        const feeTokenAddress = tokenPaymasterRequest?.feeQuote?.tokenAddress;
        common_1.Logger.warn("Requested fee token is ", feeTokenAddress);
        if (!feeTokenAddress || feeTokenAddress === Constants_js_1.ADDRESS_ZERO) {
            throw new Error("Invalid or missing token address. Token address must be part of the feeQuote in tokenPaymasterRequest");
        }
        const spender = tokenPaymasterRequest?.spender;
        common_1.Logger.warn("Spender address is ", spender);
        if (!spender || spender === Constants_js_1.ADDRESS_ZERO) {
            throw new Error("Invalid or missing spender address. Sepnder address must be part of tokenPaymasterRequest");
        }
    }
    async buildTokenPaymasterUserOp(userOp, tokenPaymasterRequest) {
        this.validateUserOpAndPaymasterRequest(userOp, tokenPaymasterRequest);
        try {
            let batchTo = [];
            let batchValue = [];
            let batchData = [];
            let newCallData = userOp.callData;
            common_1.Logger.warn("Received information about fee token address and quote ", tokenPaymasterRequest);
            if (this.paymaster && this.paymaster instanceof index_js_1.Paymaster) {
                const approvalRequest = await this.paymaster.buildTokenApprovalTransaction(tokenPaymasterRequest);
                common_1.Logger.warn("ApprovalRequest is for erc20 token ", approvalRequest.to);
                if (approvalRequest.data === "0x" || approvalRequest.to === Constants_js_1.ADDRESS_ZERO) {
                    return userOp;
                }
                if ((0, Utils_js_1.isNullOrUndefined)(userOp.callData)) {
                    throw new Error("UserOp callData cannot be undefined");
                }
                const decodedSmartAccountData = (0, viem_1.decodeFunctionData)({
                    abi: SmartAccount_js_1.BiconomyAccountAbi,
                    data: userOp.callData,
                });
                if (!decodedSmartAccountData) {
                    throw new Error("Could not parse userOp call data for this smart account");
                }
                const smartAccountExecFunctionName = decodedSmartAccountData.functionName;
                common_1.Logger.warn(`Originally an ${smartAccountExecFunctionName} method call for Biconomy Account V2`);
                if (smartAccountExecFunctionName === "execute" || smartAccountExecFunctionName === "execute_ncC") {
                    const methodArgsSmartWalletExecuteCall = decodedSmartAccountData.args;
                    const toOriginal = methodArgsSmartWalletExecuteCall[0];
                    const valueOriginal = methodArgsSmartWalletExecuteCall[1];
                    const dataOriginal = methodArgsSmartWalletExecuteCall[2];
                    batchTo.push(toOriginal);
                    batchValue.push(valueOriginal);
                    batchData.push(dataOriginal);
                }
                else if (smartAccountExecFunctionName === "executeBatch" || smartAccountExecFunctionName === "executeBatch_y6U") {
                    const methodArgsSmartWalletExecuteCall = decodedSmartAccountData.args;
                    batchTo = [...methodArgsSmartWalletExecuteCall[0]];
                    batchValue = [...methodArgsSmartWalletExecuteCall[1]];
                    batchData = [...methodArgsSmartWalletExecuteCall[2]];
                }
                if (approvalRequest.to && approvalRequest.data && approvalRequest.value) {
                    batchTo = [approvalRequest.to, ...batchTo];
                    batchValue = [BigInt(Number(approvalRequest.value.toString())), ...batchValue];
                    batchData = [approvalRequest.data, ...batchData];
                    newCallData = await this.encodeExecuteBatch(batchTo, batchValue, batchData);
                }
                const finalUserOp = {
                    ...userOp,
                    callData: newCallData,
                };
                return finalUserOp;
            }
        }
        catch (error) {
            common_1.Logger.log("Failed to update userOp. Sending back original op");
            common_1.Logger.error("Failed to update callData with error", error);
            return userOp;
        }
        return userOp;
    }
    async signUserOpHash(userOpHash, params) {
        this.isActiveValidationModuleDefined();
        const moduleSig = (await this.activeValidationModule.signUserOpHash(userOpHash, params));
        const signatureWithModuleAddress = (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)("bytes, address"), [
            moduleSig,
            this.activeValidationModule.getAddress(),
        ]);
        return signatureWithModuleAddress;
    }
    async signMessage(message) {
        this.isActiveValidationModuleDefined();
        const dataHash = typeof message === "string" ? (0, viem_1.toBytes)(message) : message;
        let signature = await this.activeValidationModule.signMessage(dataHash);
        const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);
        if (![27, 28].includes(potentiallyIncorrectV)) {
            const correctV = potentiallyIncorrectV + 27;
            signature = signature.slice(0, -2) + correctV.toString(16);
        }
        if (signature.slice(0, 2) !== "0x") {
            signature = "0x" + signature;
        }
        return signature;
    }
    async enableModule(moduleAddress) {
        const tx = await this.getEnableModuleData(moduleAddress);
        const partialUserOp = await this.buildUserOp([tx]);
        return this.sendUserOp(partialUserOp);
    }
    async getEnableModuleData(moduleAddress) {
        const callData = (0, viem_1.encodeFunctionData)({
            abi: SmartAccount_js_1.BiconomyAccountAbi,
            functionName: "enableModule",
            args: [moduleAddress],
        });
        const tx = {
            to: await this.getAddress(),
            value: "0x00",
            data: callData,
        };
        return tx;
    }
    async getSetupAndEnableModuleData(moduleAddress, moduleSetupData) {
        const callData = (0, viem_1.encodeFunctionData)({
            abi: SmartAccount_js_1.BiconomyAccountAbi,
            functionName: "setupAndEnableModule",
            args: [moduleAddress, moduleSetupData],
        });
        const tx = {
            to: await this.getAddress(),
            value: "0x00",
            data: callData,
        };
        return tx;
    }
    async disableModule(prevModule, moduleAddress) {
        const tx = await this.getDisableModuleData(prevModule, moduleAddress);
        const partialUserOp = await this.buildUserOp([tx]);
        return this.sendUserOp(partialUserOp);
    }
    async getDisableModuleData(prevModule, moduleAddress) {
        const callData = (0, viem_1.encodeFunctionData)({
            abi: SmartAccount_js_1.BiconomyAccountAbi,
            functionName: "disableModule",
            args: [prevModule, moduleAddress],
        });
        const tx = {
            to: await this.getAddress(),
            value: "0x00",
            data: callData,
        };
        return tx;
    }
    async isModuleEnabled(moduleAddress) {
        const accountContract = await this._getAccountContract();
        return accountContract.read.isModuleEnabled([moduleAddress]);
    }
    async getAllModules(pageSize) {
        pageSize = pageSize ?? 100;
        const accountContract = await this._getAccountContract();
        const result = await accountContract.read.getModulesPaginated([this.SENTINEL_MODULE, BigInt(pageSize)]);
        const modules = result[0];
        return modules;
    }
}
exports.BiconomySmartAccountV2 = BiconomySmartAccountV2;
//# sourceMappingURL=BiconomySmartAccountV2.js.map