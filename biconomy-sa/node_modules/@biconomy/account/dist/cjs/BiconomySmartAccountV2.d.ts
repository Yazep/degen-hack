import { Hex, PublicClient, GetContractReturnType } from "viem";
import { BaseSmartContractAccount, type UserOperationStruct, BatchUserOperationCallData } from "@alchemy/aa-core";
import { BaseValidationModule, ModuleInfo, SendUserOpParams } from "@biconomy/modules";
import { IPaymaster, IBundler, UserOpResponse } from "./index.js";
import { BiconomyTokenPaymasterRequest, BiconomySmartAccountV2Config, CounterFactualAddressParam, BuildUserOpOptions, Transaction, QueryParamsForAddressResolver, BiconomySmartAccountV2ConfigConstructorProps, PaymasterUserOperationDto, SimulationType } from "./utils/Types.js";
import { BiconomyAccountAbi } from "./abi/SmartAccount.js";
import { FeeQuotesOrDataResponse } from "@biconomy/paymaster";
type UserOperationKey = keyof UserOperationStruct;
export declare class BiconomySmartAccountV2 extends BaseSmartContractAccount {
    readonly biconomySmartAccountConfig: BiconomySmartAccountV2ConfigConstructorProps;
    private SENTINEL_MODULE;
    private index;
    private chainId;
    private provider;
    paymaster?: IPaymaster;
    bundler?: IBundler;
    private accountContract?;
    private defaultFallbackHandlerAddress;
    private implementationAddress;
    private scanForUpgradedAccountsFromV1;
    private maxIndexForScan;
    defaultValidationModule: BaseValidationModule;
    activeValidationModule: BaseValidationModule;
    private constructor();
    static create(biconomySmartAccountConfig: BiconomySmartAccountV2Config): Promise<BiconomySmartAccountV2>;
    getAddress(params?: CounterFactualAddressParam): Promise<Hex>;
    getAccountAddress(params?: CounterFactualAddressParam): Promise<`0x${string}`>;
    getCounterFactualAddress(params?: CounterFactualAddressParam): Promise<Hex>;
    private getCounterFactualAddressV2;
    _getAccountContract(): Promise<GetContractReturnType<typeof BiconomyAccountAbi, PublicClient>>;
    isActiveValidationModuleDefined(): boolean;
    isDefaultValidationModuleDefined(): boolean;
    setActiveValidationModule(validationModule: BaseValidationModule): BiconomySmartAccountV2;
    setDefaultValidationModule(validationModule: BaseValidationModule): BiconomySmartAccountV2;
    getV1AccountsUpgradedToV2(params: QueryParamsForAddressResolver): Promise<Hex>;
    getAccountInitCode(): Promise<Hex>;
    encodeExecute(to: Hex, value: bigint, data: Hex): Promise<Hex>;
    encodeExecuteBatch(to: Array<Hex>, value: Array<bigint>, data: Array<Hex>): Promise<Hex>;
    encodeBatchExecute(txs: BatchUserOperationCallData): Promise<Hex>;
    getDummySignatures(params?: ModuleInfo): Promise<Hex>;
    getDummySignature(): Hex;
    getDummyPaymasterData(): string;
    validateUserOp(userOp: Partial<UserOperationStruct>, requiredFields: UserOperationKey[]): boolean;
    signUserOp(userOp: Partial<UserOperationStruct>, params?: SendUserOpParams): Promise<UserOperationStruct>;
    getSignatureWithModuleAddress(moduleSignature: Hex, moduleAddress?: Hex): Hex;
    getPaymasterUserOp(userOp: Partial<UserOperationStruct>, paymasterServiceData: PaymasterUserOperationDto): Promise<Partial<UserOperationStruct>>;
    private getPaymasterAndData;
    private getPaymasterFeeQuotesOrData;
    getTokenFees(manyOrOneTransactions: Transaction | Transaction[], buildUseropDto: BuildUserOpOptions): Promise<FeeQuotesOrDataResponse>;
    sendUserOp(userOp: Partial<UserOperationStruct>, params?: SendUserOpParams): Promise<UserOpResponse>;
    sendSignedUserOp(userOp: UserOperationStruct, simulationType?: SimulationType): Promise<UserOpResponse>;
    getUserOpHash(userOp: Partial<UserOperationStruct>): Promise<Hex>;
    estimateUserOpGas(userOp: Partial<UserOperationStruct>): Promise<Partial<UserOperationStruct>>;
    getNonce(nonceKey?: number): Promise<bigint>;
    private getBuildUserOpNonce;
    sendTransaction(manyOrOneTransactions: Transaction | Transaction[], buildUseropDto?: BuildUserOpOptions): Promise<UserOpResponse>;
    buildUserOp(transactions: Transaction[], buildUseropDto?: BuildUserOpOptions): Promise<Partial<UserOperationStruct>>;
    private validateUserOpAndPaymasterRequest;
    buildTokenPaymasterUserOp(userOp: Partial<UserOperationStruct>, tokenPaymasterRequest: BiconomyTokenPaymasterRequest): Promise<Partial<UserOperationStruct>>;
    signUserOpHash(userOpHash: string, params?: ModuleInfo): Promise<Hex>;
    signMessage(message: string | Uint8Array): Promise<Hex>;
    enableModule(moduleAddress: Hex): Promise<UserOpResponse>;
    getEnableModuleData(moduleAddress: Hex): Promise<Transaction>;
    getSetupAndEnableModuleData(moduleAddress: Hex, moduleSetupData: Hex): Promise<Transaction>;
    disableModule(prevModule: Hex, moduleAddress: Hex): Promise<UserOpResponse>;
    getDisableModuleData(prevModule: Hex, moduleAddress: Hex): Promise<Transaction>;
    isModuleEnabled(moduleAddress: Hex): Promise<boolean>;
    getAllModules(pageSize?: number): Promise<Array<string>>;
}
export {};
