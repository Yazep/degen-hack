"use strict";import{keccak256 as w,encodePacked as F,getCreate2Address as G,encodeAbiParameters as x,parseAbiParameters as v,toHex as p,toBytes as R,encodeFunctionData as f,createPublicClient as B,http as N,concatHex as S,getContract as P,decodeFunctionData as _}from"viem";import{BaseSmartContractAccount as T,getChain as y}from"@alchemy/aa-core";import{isNullOrUndefined as E,packUserOp as k}from"./utils/Utils.js";import{BaseValidationModule as D,createECDSAOwnershipValidationModule as L}from"@biconomy/modules";import{Paymaster as M,PaymasterMode as U,Bundler as H,extractChainIdFromBundlerUrl as V,convertSigner as C}from"./index.js";import{ADDRESS_RESOLVER_ADDRESS as j,BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION as Q,DEFAULT_BICONOMY_FACTORY_ADDRESS as O,DEFAULT_FALLBACK_HANDLER_ADDRESS as q,PROXY_CREATION_CODE as W,ADDRESS_ZERO as m,DEFAULT_ENTRYPOINT_ADDRESS as Y,ERROR_MESSAGES as b}from"./utils/Constants.js";import{BiconomyFactoryAbi as $}from"./abi/Factory.js";import{BiconomyAccountAbi as h}from"./abi/SmartAccount.js";import{AccountResolverAbi as K}from"./abi/AccountResolver.js";import{Logger as u}from"@biconomy/common";export class BiconomySmartAccountV2 extends T{constructor(e){super({...e,chain:y(e.chainId),rpcClient:e.rpcUrl||y(e.chainId).rpcUrls.default.http[0],entryPointAddress:e.entryPointAddress??Y,accountAddress:e.accountAddress??void 0,factoryAddress:e.factoryAddress??O}),Object.defineProperty(this,"biconomySmartAccountConfig",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"SENTINEL_MODULE",{enumerable:!0,configurable:!0,writable:!0,value:"0x0000000000000000000000000000000000000001"}),Object.defineProperty(this,"index",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"chainId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"provider",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"paymaster",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"bundler",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"accountContract",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"defaultFallbackHandlerAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"implementationAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"scanForUpgradedAccountsFromV1",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxIndexForScan",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"defaultValidationModule",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"activeValidationModule",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.defaultValidationModule=e.defaultValidationModule,this.activeValidationModule=e.activeValidationModule,this.index=e.index??0,this.chainId=e.chainId,this.bundler=e.bundler,this.implementationAddress=e.implementationAddress??Q.V2_0_0,e.biconomyPaymasterApiKey?this.paymaster=new M({paymasterUrl:`https://paymaster.biconomy.io/api/v1/${e.chainId}/${e.biconomyPaymasterApiKey}`}):this.paymaster=e.paymaster,this.bundler=e.bundler;const t=this.factoryAddress===O?q:e.defaultFallbackHandler;if(!t)throw new Error("Default Fallback Handler address is not provided");this.defaultFallbackHandlerAddress=t,this.defaultValidationModule=e.defaultValidationModule,this.activeValidationModule=e.activeValidationModule,this.provider=B({chain:y(e.chainId),transport:N(e.rpcUrl||y(e.chainId).rpcUrls.default.http[0])}),this.scanForUpgradedAccountsFromV1=e.scanForUpgradedAccountsFromV1??!1,this.maxIndexForScan=e.maxIndexForScan??10}static async create(e){let t=e.chainId,a,r=e.rpcUrl;if(e.signer){const n=await C(e.signer,!!t);!t&&n.chainId&&(t=n.chainId),!r&&n.rpcUrl&&(r=n.rpcUrl),a=n.signer}if(!t){if(e.bundlerUrl)t=V(e.bundlerUrl);else if(e.bundler){const n=e.bundler.getBundlerUrl();t=V(n)}}if(!t)throw new Error("chainId required");const s=e.bundler??new H({bundlerUrl:e.bundlerUrl,chainId:t});let i=e.defaultValidationModule;i||(i=await L({signer:a}));const d=e?.activeValidationModule??i;if(a||(a=await d.getSigner()),!a)throw new Error("signer required");const o={...e,defaultValidationModule:i,activeValidationModule:d,chainId:t,bundler:s,signer:a,rpcUrl:r};return new BiconomySmartAccountV2(o)}async getAddress(e){return this.accountAddress==null&&(this.accountAddress=await this.getCounterFactualAddress(e)),this.accountAddress}async getAccountAddress(e){return(this.accountAddress==null||this.accountAddress==null)&&(this.accountAddress=await this.getCounterFactualAddress(e)),this.accountAddress}async getCounterFactualAddress(e){const t=e?.validationModule??this.defaultValidationModule,a=e?.index??this.index,r=e?.maxIndexForScan??this.maxIndexForScan;if(e?.scanForUpgradedAccountsFromV1??this.scanForUpgradedAccountsFromV1){const o=await(await t.getSigner()).getAddress(),n=t.getAddress(),A=await t.getInitData(),l={eoaAddress:o,index:a,moduleAddress:n,moduleSetupData:A,maxIndexForScan:r},c=await this.getV1AccountsUpgradedToV2(l);if(c!==m)return c}return await this.getCounterFactualAddressV2({validationModule:t,index:a})}async getCounterFactualAddressV2(e){const t=e?.validationModule??this.defaultValidationModule,a=e?.index??this.index;try{const r=f({abi:h,functionName:"init",args:[this.defaultFallbackHandlerAddress,t.getAddress(),await t.getInitData()]}),s=w(F(["bytes","uint256"],[W,BigInt(this.implementationAddress)])),i=w(F(["bytes32","uint256"],[w(r),BigInt(a)]));return G({from:this.factoryAddress,salt:i,bytecodeHash:s})}catch(r){throw new Error(`Failed to get counterfactual address, ${r}`)}}async _getAccountContract(){return this.accountContract==null&&(this.accountContract=P({address:await this.getAddress(),abi:h,client:this.provider})),this.accountContract}isActiveValidationModuleDefined(){if(!this.activeValidationModule)throw new Error("Must provide an instance of active validation module.");return!0}isDefaultValidationModuleDefined(){if(!this.defaultValidationModule)throw new Error("Must provide an instance of default validation module.");return!0}setActiveValidationModule(e){return e instanceof D&&(this.activeValidationModule=e),this}setDefaultValidationModule(e){return e instanceof D&&(this.defaultValidationModule=e),this}async getV1AccountsUpgradedToV2(e){const t=e.maxIndexForScan??this.maxIndexForScan,a=P({address:j,abi:K,client:{public:this.provider}});if(e.moduleAddress&&e.moduleSetupData){const s=(await a.read.resolveAddressesFlexibleForV2([e.eoaAddress,t,e.moduleAddress,e.moduleSetupData])).find(i=>i.factoryVersion==="v1"&&i.currentVersion==="2.0.0"&&Number(i.deploymentIndex.toString())===e.index);return s?s.accountAddress:m}else return m}async getAccountInitCode(){return this.isDefaultValidationModuleDefined(),S([this.factoryAddress,f({abi:$,functionName:"deployCounterFactualAccount",args:[this.defaultValidationModule.getAddress(),await this.defaultValidationModule.getInitData(),BigInt(this.index)]})])}async encodeExecute(e,t,a){return f({abi:h,functionName:"execute_ncC",args:[e,t,a]})}async encodeExecuteBatch(e,t,a){return f({abi:h,functionName:"executeBatch_y6U",args:[e,t,a]})}async encodeBatchExecute(e){const[t,a,r]=e.reduce((s,i)=>(s[0].push(i.target),s[1].push(i.data),s[2].push(i.value||BigInt(0)),s),[[],[],[]]);return this.encodeExecuteBatch(t,r,a)}async getDummySignatures(e){return this.isActiveValidationModuleDefined(),await this.activeValidationModule.getDummySignature(e)}getDummySignature(){throw new Error("Method not implemented! Call getDummySignatures instead.")}getDummyPaymasterData(){return"0x"}validateUserOp(e,t){for(const a of t)if(!e[a])throw new Error(`${String(a)} is missing in the UserOp`);return!0}async signUserOp(e,t){this.isActiveValidationModuleDefined();const a=["sender","nonce","initCode","callData","callGasLimit","verificationGasLimit","preVerificationGas","maxFeePerGas","maxPriorityFeePerGas","paymasterAndData"];this.validateUserOp(e,a);const r=await this.getUserOpHash(e),s=await this.activeValidationModule.signUserOpHash(r,t),i=this.getSignatureWithModuleAddress(s,this.activeValidationModule.getAddress());return e.signature=i,e}getSignatureWithModuleAddress(e,t){const a=t??this.activeValidationModule.getAddress();return x(v("bytes, address"),[e,a])}async getPaymasterUserOp(e,t){if(t.mode===U.SPONSORED)return this.getPaymasterAndData(e,t);if(t.mode===U.ERC20)if(t?.feeQuote){const{feeQuote:a,spender:r,maxApproval:s=!1}=t;if(u.log("there is a feeQuote: ",a),!r)throw new Error(b.SPENDER_REQUIRED);if(!a)throw new Error(b.FAILED_FEE_QUOTE_FETCH);const i=await this.buildTokenPaymasterUserOp(e,{...t,spender:r,maxApproval:s,feeQuote:a});return this.getPaymasterAndData(i,{...t,feeTokenAddress:a.tokenAddress,calculateGasLimits:!0})}else if(t?.preferredToken){const{preferredToken:a}=t;u.log("there is a preferred token: ",a);const r=await this.getPaymasterFeeQuotesOrData(e,t),s=r.tokenPaymasterAddress,i=r.feeQuotes?.[0];if(!s)throw new Error(b.SPENDER_REQUIRED);if(!i)throw new Error(b.FAILED_FEE_QUOTE_FETCH);return this.getPaymasterUserOp(e,{...t,feeQuote:i,spender:s})}else return u.log("ERC20 mode without feeQuote or preferredToken provided. Passing through unchanged."),e;throw new Error("Invalid paymaster mode")}async getPaymasterAndData(e,t){const r=await this.paymaster.getPaymasterAndData(e,t);return{...e,...r}}async getPaymasterFeeQuotesOrData(e,t){const a=this.paymaster,r=t?.preferredToken?[t?.preferredToken]:t?.tokenList?.length?t?.tokenList:[];return a.getPaymasterFeeQuotesOrData(e,{...t,tokenList:r})}async getTokenFees(e,t){const a=Array.isArray(e)?e:[e],r=await this.buildUserOp(a,t);if(!t.paymasterServiceData)throw new Error("paymasterServiceData was not provided");return this.getPaymasterFeeQuotesOrData(r,t.paymasterServiceData)}async sendUserOp(e,t){delete e.signature;const a=await this.signUserOp(e,t);return await this.sendSignedUserOp(a,t?.simulationType)}async sendSignedUserOp(e,t){const a=["sender","nonce","initCode","callData","callGasLimit","verificationGasLimit","preVerificationGas","maxFeePerGas","maxPriorityFeePerGas","paymasterAndData","signature"];if(this.validateUserOp(e,a),!this.bundler)throw new Error("Bundler is not provided");return u.warn("userOp being sent to the bundler",e),await this.bundler.sendUserOp(e,t)}async getUserOpHash(e){const t=w(k(e,!0)),a=x(v("bytes32, address, uint256"),[t,this.entryPoint.address,BigInt(this.chainId)]);return w(a)}async estimateUserOpGas(e){if(!this.bundler)throw new Error("Bundler is not provided");const t=["sender","nonce","initCode","callData"];this.validateUserOp(e,t);const a=e,{callGasLimit:r,verificationGasLimit:s,preVerificationGas:i,maxFeePerGas:d,maxPriorityFeePerGas:o}=await this.bundler.estimateUserOpGas(e);if(!e.maxFeePerGas&&!e.maxPriorityFeePerGas&&(!d||!o)){const n=await this.provider.estimateFeesPerGas();n.maxFeePerGas?.toString()?a.maxFeePerGas="0x"+n.maxFeePerGas.toString(16):n.gasPrice?.toString()?a.maxFeePerGas="0x"+n.gasPrice.toString(16):a.maxFeePerGas="0x"+(await this.provider.getGasPrice()).toString(16),n.maxPriorityFeePerGas?.toString()?a.maxPriorityFeePerGas="0x"+n.maxPriorityFeePerGas?.toString():n.gasPrice?.toString()?a.maxPriorityFeePerGas=p(Number(n.gasPrice?.toString())):a.maxPriorityFeePerGas="0x"+(await this.provider.getGasPrice()).toString(16)}else a.maxFeePerGas=p(Number(d))??e.maxFeePerGas,a.maxPriorityFeePerGas=p(Number(o))??e.maxPriorityFeePerGas;return a.verificationGasLimit=p(Number(s))??e.verificationGasLimit,a.callGasLimit=p(Number(r))??e.callGasLimit,a.preVerificationGas=p(Number(i))??e.preVerificationGas,a.paymasterAndData||(a.paymasterAndData="0x"),a}async getNonce(e){const t=e??0;try{const a=await this.getAddress();return await this.entryPoint.read.getNonce([a,BigInt(t)])}catch{return BigInt(0)}}async getBuildUserOpNonce(e){let t=BigInt(0);try{if(e?.nonceOverride)t=BigInt(e?.nonceOverride);else{const a=e?.nonceKey??0;t=await this.getNonce(a)}}catch{u.warn("Error while getting nonce for the account. This is expected for undeployed accounts set nonce to 0")}return t}async sendTransaction(e,t){const a=await this.buildUserOp(Array.isArray(e)?e:[e],t);return this.sendUserOp(a,{simulationType:t?.simulationType,...t?.params})}async buildUserOp(e,t){const a=e.map(g=>g.to),r=e.map(g=>g.data??"0x"),s=e.map(g=>g.value??BigInt(0)),i=this.getInitCode(),d=this.getDummySignatures(t?.params),[o,n,A]=await Promise.all([this.getBuildUserOpNonce(t?.nonceOptions),i,d]);if(e.length===0)throw new Error("Transactions array cannot be empty");let l="0x";e.length>1||t?.forceEncodeForBatch?l=await this.encodeExecuteBatch(a,s,r):l=await this.encodeExecute(a[0],s[0],r[0]);let c={sender:await this.getAccountAddress(),nonce:p(o),initCode:n,callData:l};return c.signature=A,c=await this.estimateUserOpGas(c),t?.paymasterServiceData&&(c=await this.getPaymasterUserOp(c,t.paymasterServiceData)),u.log("UserOp after estimation ",c),c}validateUserOpAndPaymasterRequest(e,t){if(E(e.callData))throw new Error("UserOp callData cannot be undefined");const a=t?.feeQuote?.tokenAddress;if(u.warn("Requested fee token is ",a),!a||a===m)throw new Error("Invalid or missing token address. Token address must be part of the feeQuote in tokenPaymasterRequest");const r=t?.spender;if(u.warn("Spender address is ",r),!r||r===m)throw new Error("Invalid or missing spender address. Sepnder address must be part of tokenPaymasterRequest")}async buildTokenPaymasterUserOp(e,t){this.validateUserOpAndPaymasterRequest(e,t);try{let a=[],r=[],s=[],i=e.callData;if(u.warn("Received information about fee token address and quote ",t),this.paymaster&&this.paymaster instanceof M){const d=await this.paymaster.buildTokenApprovalTransaction(t);if(u.warn("ApprovalRequest is for erc20 token ",d.to),d.data==="0x"||d.to===m)return e;if(E(e.callData))throw new Error("UserOp callData cannot be undefined");const o=_({abi:h,data:e.callData});if(!o)throw new Error("Could not parse userOp call data for this smart account");const n=o.functionName;if(u.warn(`Originally an ${n} method call for Biconomy Account V2`),n==="execute"||n==="execute_ncC"){const l=o.args,c=l[0],g=l[1],I=l[2];a.push(c),r.push(g),s.push(I)}else if(n==="executeBatch"||n==="executeBatch_y6U"){const l=o.args;a=[...l[0]],r=[...l[1]],s=[...l[2]]}return d.to&&d.data&&d.value&&(a=[d.to,...a],r=[BigInt(Number(d.value.toString())),...r],s=[d.data,...s],i=await this.encodeExecuteBatch(a,r,s)),{...e,callData:i}}}catch(a){return u.log("Failed to update userOp. Sending back original op"),u.error("Failed to update callData with error",a),e}return e}async signUserOpHash(e,t){this.isActiveValidationModuleDefined();const a=await this.activeValidationModule.signUserOpHash(e,t);return x(v("bytes, address"),[a,this.activeValidationModule.getAddress()])}async signMessage(e){this.isActiveValidationModuleDefined();const t=typeof e=="string"?R(e):e;let a=await this.activeValidationModule.signMessage(t);const r=parseInt(a.slice(-2),16);if(![27,28].includes(r)){const s=r+27;a=a.slice(0,-2)+s.toString(16)}return a.slice(0,2)!=="0x"&&(a="0x"+a),a}async enableModule(e){const t=await this.getEnableModuleData(e),a=await this.buildUserOp([t]);return this.sendUserOp(a)}async getEnableModuleData(e){const t=f({abi:h,functionName:"enableModule",args:[e]});return{to:await this.getAddress(),value:"0x00",data:t}}async getSetupAndEnableModuleData(e,t){const a=f({abi:h,functionName:"setupAndEnableModule",args:[e,t]});return{to:await this.getAddress(),value:"0x00",data:a}}async disableModule(e,t){const a=await this.getDisableModuleData(e,t),r=await this.buildUserOp([a]);return this.sendUserOp(r)}async getDisableModuleData(e,t){const a=f({abi:h,functionName:"disableModule",args:[e,t]});return{to:await this.getAddress(),value:"0x00",data:a}}async isModuleEnabled(e){return(await this._getAccountContract()).read.isModuleEnabled([e])}async getAllModules(e){return e=e??100,(await(await this._getAccountContract()).read.getModulesPaginated([this.SENTINEL_MODULE,BigInt(e)]))[0]}}
