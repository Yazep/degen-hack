import { type Address, type Chain, type CustomSource, type Hex, type LocalAccount, type PublicClient, type SignableMessage, type Transport, type TypedData, type TypedDataDefinition } from "viem";
import type { SmartAccountSigner } from "../signer/types.js";
import type { IsUndefined } from "../utils/types.js";
type Tx = {
    target: Address;
    value?: bigint;
    data: Hex | "0x";
};
export type GetAccountParameter<TAccount extends SmartContractAccount | undefined = SmartContractAccount | undefined, TAccountOverride extends SmartContractAccount = SmartContractAccount> = IsUndefined<TAccount> extends true ? {
    account: TAccountOverride;
} : {
    account?: TAccountOverride;
};
export type UpgradeToAndCallParams = {
    upgradeToAddress: Address;
    upgradeToInitData: Hex;
};
export type OwnedSmartContractAccount<Name extends string = string, TOwner extends SmartAccountSigner = SmartAccountSigner> = SmartContractAccount<Name> & {
    getOwner: () => TOwner;
    setOwner: (owner: TOwner) => void;
};
export type SmartContractAccount<Name extends string = string> = LocalAccount<Name> & {
    source: Name;
    getDummySignature: () => Hex;
    encodeExecute: (tx: Tx) => Promise<Hex>;
    encodeBatchExecute: (txs: Tx[]) => Promise<Hex>;
    signUserOperationHash: (uoHash: Hex) => Promise<Hex>;
    signMessageWith6492: (params: {
        message: SignableMessage;
    }) => Promise<Hex>;
    signTypedDataWith6492: <const typedData extends TypedData | Record<string, unknown>, primaryType extends keyof typedData | "EIP712Domain" = keyof typedData>(typedDataDefinition: TypedDataDefinition<typedData, primaryType>) => Promise<Hex>;
    encodeUpgradeToAndCall: (params: UpgradeToAndCallParams) => Promise<Hex>;
    getNonce(): Promise<bigint>;
    getInitCode: () => Promise<Hex>;
    isAccountDeployed: () => Promise<boolean>;
    getFactoryAddress: () => Address;
    getEntrypoint: () => Address;
    getImplementationAddress: () => Promise<"0x0" | Address>;
};
export type ToSmartContractAccountParams<Name extends string = string, TTransport extends Transport = Transport, TChain extends Chain = Chain> = {
    source: Name;
    transport: TTransport;
    chain: TChain;
    entrypointAddress: Address;
    accountAddress?: Address;
    getAccountInitCode: () => Promise<Hex>;
    getDummySignature: () => Hex;
    encodeExecute: (tx: Tx) => Promise<Hex>;
    encodeBatchExecute?: (txs: Tx[]) => Promise<Hex>;
    signUserOperationHash?: (uoHash: Hex) => Promise<Hex>;
    encodeUpgradeToAndCall?: (params: UpgradeToAndCallParams) => Promise<Hex>;
} & Omit<CustomSource, "signTransaction" | "address">;
export declare const parseFactoryAddressFromAccountInitCode: (initCode: Hex) => `0x${string}`[];
export declare const getAccountAddress: ({ client, entrypointAddress, accountAddress, getAccountInitCode, }: {
    client: PublicClient;
    entrypointAddress: Address;
    accountAddress?: `0x${string}` | undefined;
    getAccountInitCode: () => Promise<Hex>;
}) => Promise<`0x${string}`>;
export declare function toSmartContractAccount<Name extends string = string, TTransport extends Transport = Transport, TChain extends Chain = Chain>({ transport, chain, source, entrypointAddress, accountAddress, getAccountInitCode, signMessage, signTypedData, encodeBatchExecute, encodeExecute, getDummySignature, signUserOperationHash, encodeUpgradeToAndCall, }: ToSmartContractAccountParams<Name, TTransport, TChain>): Promise<SmartContractAccount<Name>>;
export {};
//# sourceMappingURL=smartContractAccount.d.ts.map