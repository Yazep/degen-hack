"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForUserOperationTransaction = void 0;
const actions_1 = require("viem/actions");
const isSmartAccountClient_js_1 = require("../../client/isSmartAccountClient.js");
const client_js_1 = require("../../errors/client.js");
const transaction_js_1 = require("../../errors/transaction.js");
const logger_js_1 = require("../../logger.js");
const waitForUserOperationTransaction = async (client, args) => {
    const { hash } = args;
    if (!(0, isSmartAccountClient_js_1.isBaseSmartAccountClient)(client)) {
        throw new client_js_1.IncompatibleClientError("BaseSmartAccountClient", "upgradeAccount");
    }
    for (let i = 0; i < client.txMaxRetries; i++) {
        const txRetryIntervalWithJitterMs = client.txRetryIntervalMs * Math.pow(client.txRetryMultiplier, i) +
            Math.random() * 100;
        await new Promise((resolve) => setTimeout(resolve, txRetryIntervalWithJitterMs));
        const receipt = await client
            .getUserOperationReceipt(hash)
            .catch((e) => {
            logger_js_1.Logger.error(`[SmartAccountProvider] waitForUserOperationTransaction error fetching receipt for ${hash}: ${e}`);
        });
        if (receipt) {
            return (0, actions_1.getTransaction)(client, {
                hash: receipt.receipt.transactionHash,
            }).then((x) => x.hash);
        }
    }
    throw new transaction_js_1.FailedToFindTransactionError(hash);
};
exports.waitForUserOperationTransaction = waitForUserOperationTransaction;
//# sourceMappingURL=waitForUserOperationTransacation.js.map