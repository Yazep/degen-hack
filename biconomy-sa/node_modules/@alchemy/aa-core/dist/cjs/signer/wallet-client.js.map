{"version":3,"file":"wallet-client.js","sourceRoot":"","sources":["../../../src/signer/wallet-client.ts"],"names":[],"mappings":";;;AAAA,+BAQc;AACd,mDAA6D;AAG7D,MAAa,kBAAkB;IAI7B,YAAY,MAAoB,EAAE,UAAkB;QAHpD;;;;;WAAmB;QACnB;;;;;WAAoB;QAUpB;;;;mBAA2C,KAAK,IAAI,EAAE;gBACpD,IAAI,SAAS,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC;gBAChD,OAAO,IAAA,iBAAU,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;YAClC,CAAC;WAAC;QAEO;;;;mBAEqB,KAAK,EAAE,OAAO,EAAE,EAAE;gBAC9C,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,CAAC,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC;gBAEhE,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,CAAC,IAAA,YAAK,EAAC,OAAO,CAAC,EAAE,CAAC;oBACnD,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;wBAC5B,OAAO;wBACP,OAAO;qBACR,CAAC,CAAC;gBACL,CAAC;qBAAM,CAAC;oBACN,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;wBAC5B,OAAO;wBACP,OAAO,EAAE,EAAE,GAAG,EAAE,OAAO,EAAE;qBAC1B,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;WAAC;QAEF;;;;mBAAgB,KAAK,EAInB,SAAwD,EAC1C,EAAE;gBAChB,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,CAAC,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC;gBAEhE,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC;oBAC9B,OAAO;oBACP,GAAG,SAAS;iBACb,CAAC,CAAC;YACL,CAAC;WAAC;QA1CA,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC;QACpB,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,MAAM,IAAI,kCAAsB,CAAC,UAAU,CAAC,CAAC;QAC/C,CAAC;QACD,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;CAsCF;AAhDD,gDAgDC","sourcesContent":["import {\n  getAddress,\n  isHex,\n  type ByteArray,\n  type Hex,\n  type TypedData,\n  type TypedDataDefinition,\n  type WalletClient,\n} from \"viem\";\nimport { InvalidSignerTypeError } from \"../errors/signer.js\";\nimport type { SmartAccountSigner } from \"./types\";\n\nexport class WalletClientSigner implements SmartAccountSigner<WalletClient> {\n  signerType: string;\n  inner: WalletClient;\n\n  constructor(client: WalletClient, signerType: string) {\n    this.inner = client;\n    if (!signerType) {\n      throw new InvalidSignerTypeError(signerType);\n    }\n    this.signerType = signerType;\n  }\n\n  getAddress: () => Promise<`0x${string}`> = async () => {\n    let addresses = await this.inner.getAddresses();\n    return getAddress(addresses[0]);\n  };\n\n  readonly signMessage: (\n    message: string | Hex | ByteArray\n  ) => Promise<`0x${string}`> = async (message) => {\n    const account = this.inner.account ?? (await this.getAddress());\n\n    if (typeof message === \"string\" && !isHex(message)) {\n      return this.inner.signMessage({\n        account,\n        message,\n      });\n    } else {\n      return this.inner.signMessage({\n        account,\n        message: { raw: message },\n      });\n    }\n  };\n\n  signTypedData = async <\n    const TTypedData extends TypedData | { [key: string]: unknown },\n    TPrimaryType extends string = string\n  >(\n    typedData: TypedDataDefinition<TTypedData, TPrimaryType>\n  ): Promise<Hex> => {\n    const account = this.inner.account ?? (await this.getAddress());\n\n    return this.inner.signTypedData({\n      account,\n      ...typedData,\n    });\n  };\n}\n"]}