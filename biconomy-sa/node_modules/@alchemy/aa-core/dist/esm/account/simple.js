import { concatHex, encodeFunctionData, hexToBytes, } from "viem";
import { SimpleAccountAbi } from "../abis/SimpleAccountAbi.js";
import { SimpleAccountFactoryAbi } from "../abis/SimpleAccountFactoryAbi.js";
import { createBundlerClient } from "../client/bundlerClient.js";
import { AccountRequiresOwnerError } from "../errors/account.js";
import { BaseSmartContractAccount } from "./base.js";
import { SimpleSmartAccountParamsSchema } from "./schema.js";
import { toSmartContractAccount, } from "./smartContractAccount.js";
class SimpleSmartContractAccount extends BaseSmartContractAccount {
    constructor(params) {
        SimpleSmartAccountParamsSchema().parse(params);
        const client = createBundlerClient({
            transport: params.transport,
            chain: params.chain,
        });
        super({ ...params, rpcClient: client });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.owner = params.owner;
        this.index = params.index ?? 0n;
    }
    getDummySignature() {
        return "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    }
    async encodeExecute(target, value, data) {
        return encodeFunctionData({
            abi: SimpleAccountAbi,
            functionName: "execute",
            args: [target, value, data],
        });
    }
    async encodeBatchExecute(txs) {
        const [targets, datas] = txs.reduce((accum, curr) => {
            accum[0].push(curr.target);
            accum[1].push(curr.data);
            return accum;
        }, [[], []]);
        return encodeFunctionData({
            abi: SimpleAccountAbi,
            functionName: "executeBatch",
            args: [targets, datas],
        });
    }
    signMessage(msg) {
        if (typeof msg === "string" && msg.startsWith("0x")) {
            msg = hexToBytes(msg);
        }
        else if (typeof msg === "string") {
            msg = new TextEncoder().encode(msg);
        }
        return this.owner.signMessage(msg);
    }
    setOwner(owner) {
        this.owner = owner;
    }
    async getAccountInitCode() {
        return concatHex([
            this.factoryAddress,
            encodeFunctionData({
                abi: SimpleAccountFactoryAbi,
                functionName: "createAccount",
                args: [await this.owner.getAddress(), this.index],
            }),
        ]);
    }
}
export const createSimpleSmartAccount = async (params) => {
    if (!params.owner)
        throw new AccountRequiresOwnerError("SimpleAccount");
    const simpleAccount = new SimpleSmartContractAccount(params);
    const parsedParams = SimpleSmartAccountParamsSchema().parse(params);
    const base = await toSmartContractAccount({
        source: "SimpleAccount",
        transport: params.transport,
        chain: params.chain,
        encodeBatchExecute: simpleAccount.encodeBatchExecute.bind(simpleAccount),
        encodeExecute: (tx) => simpleAccount.encodeExecute.bind(simpleAccount)(tx.target, tx.value ?? 0n, tx.data),
        entrypointAddress: simpleAccount.getEntryPointAddress(),
        getAccountInitCode: async () => {
            if (parsedParams.initCode)
                return parsedParams.initCode;
            return simpleAccount.getAccountInitCode();
        },
        getDummySignature: simpleAccount.getDummySignature.bind(simpleAccount),
        signMessage: ({ message }) => simpleAccount.signMessage(typeof message === "string" ? message : message.raw),
        signTypedData: simpleAccount.signTypedData.bind(simpleAccount),
        accountAddress: parsedParams.accountAddress,
    });
    return {
        ...base,
        getOwner: () => simpleAccount.getOwner(),
        setOwner: (owner) => simpleAccount.setOwner.bind(simpleAccount)(owner),
    };
};
//# sourceMappingURL=simple.js.map